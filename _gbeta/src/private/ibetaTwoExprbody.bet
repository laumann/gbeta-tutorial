(* FILE "./private/ibetaTwoExprbody.bet"
 *
 * Copyright (C) 1997-2011 Erik Ernst
 *
 * This file is part of "gbeta" -- a generalized version of the
 * programming language BETA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is destributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Among other things, the copyright notice and this notice must be
 * preserved on all copies.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, probably in a file named COPYING; if not,
 * write to the Free Software Foundation, Inc., 675 Mass Ave,
 * Cambridge, MA 02139, USA.
 *
 * To contact the author by email: eernst@cs.au.dk
 *
 * To contact the author by snail-mail:
 *    Erik Ernst
 *    Department of Computer Science
 *    University of Aarhus
 *    DK-8200 Aarhus N
 *    Denmark
 *)

ORIGIN 'ibetaTwobody';
INCLUDE 'ibetaCommonlib';
INCLUDE 'ibetaTwolib'

(************************************************************
 *                                                          *
 *                        l2UnaryExp                        *
 *                                                          *
 ************************************************************)

-- UnaryExpPrint:dopart --
do
   INNER;
   (dest[],indentation,false)->operand.print

-- UnaryExpScanImpl:dopart --
do
   INNER;
   (preCB[],postCB[])->operand.scanImpl

-- UnaryExpGetTranOut:dopart --
do
   (depth+1,focus[],context[]
   ,(this(l2UnaryExp)[],usageAst[])->addUsageAst)
     ->operand.getStaticTransientOut
     ->operandTransient[];
   INNER

-- UnaryExpGetTranIn:dopart --
do
   ('Attempt to assign to a unary expression'
   ,'Remove the unary operator'
   ,this(l2UnaryExp)[]->newUsageAst
   ,NONE)->staticError

-- UnaryExpGetCplr:dopart --
do
   (focus[],context[],usageAst[])
     ->operand.getExitCompiler
     ->operandCplr[];
   INNER

-- UnaryExpGetEnterCplr:dopart --
do
   ('Attempt to assign to a unary expression'
   ,'Remove the unary operator'
   ,(this(l2UnaryExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- UnaryExpGetExitCplr:dopart --
do
   (focus[],context[],usageAst[])
     ->operand.getExitCompiler
     ->operandCplr[];
   INNER

-- UnaryExpGetEnterExitCplr:dopart --
do
   ('Attempt to assign-then-evaluate a unary expression'
   ,'Remove the unary operator'
   ,(this(l2UnaryExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(************************************************************
 *                                                          *
 *                         l2BinExp                         *
 *                                                          *
 ************************************************************)

-- BinExpGetExitCompilerLib:attributes --

delegate2ExitCompiler: exitOnceCompiler
  (* Will use cplr1 and cplr2 to generate code to produce a pair of
   * values to be processed by the subpattern to produce the final
   * result.  Note that only one value can be generated by the
   * subcompilers, generating multiple values is treated as an error.
   * To use: furtherbind 'generate' using 'stran1' and 'stran2' to combine
   * the computed values; NB: imports 'cplr1' and 'cplr2' to use the
   * two subexpression compilers generated at the general level *)
  (# stran1,stran2,resultSTran: ^staticTransient;
     coercionPos: ^betaByteCode;
     doCoerce:< binCoerceBase;
     prepare::(# #);
     generate::<
       (#
       do (program[],cInfo[])->cplr1.prepare;
          (if cplr1.more then
              (program[],cInfo[])
                ->cplr1.generate
                ->stran1[];
              program.lastLink[]->coercionPos[]
           else
              ('Left operand yields no values'
              ,'Use an expression that yields one value'
              ,(this(l2BinExp)[],usageAst[])->addUsageAst
              ,NONE)->staticError
          if);
          (if not cplr1.more then
              (program[],cInfo[])
                ->cplr1.cleanup
           else
              ('Left operand yields more than one value'
              ,'Use an expression that yields one value'
              ,(this(l2BinExp)[],usageAst[])->addUsageAst
              ,NONE)->staticError
          if);
          (program[],cInfo[])->cplr2.prepare;
          (if cplr2.more then
              (program[],cInfo[])
                ->cplr2.generate
                ->stran2[]
           else
              ('Right operand yields no values'
              ,'Use an expression that yields one value'
              ,(this(l2BinExp)[],usageAst[])->addUsageAst
              ,NONE)->staticError
          if);
          (if not cplr2.more then
              (program[],cInfo[])
                ->cplr2.cleanup
           else
              ('Right operand yields more than one value'
              ,'Use an expression that yields one value'
              ,(this(l2BinExp)[],usageAst[])->addUsageAst
              ,NONE)->staticError
          if);
          (program[],coercionPos[],stran1[],stran2[],cInfo[],usageAst[])
            ->doCoerce
            ->resultSTran[];
          INNER
       #);
     cleanup::(# #)
  #);

delegate2BoolCombineExitCompiler: exitOnceCompiler
  (* Will use cplr1 and cplr2 to generate values to combine in the
   * subpattern.  The subcompilers may generate multiple values (as
   * long as they generate the same number of values), and each step
   * is required to produce a boolean result, which is then accumulated
   * by the code generated by 'doCombine'; for instance, an equals
   * operator would combine using 'and' because two composite values
   * are equal iff every corresponding subvalue pair is equal.
   * To use: furtherbind 'generate' using 'stran1' and 'stran2' to
   * combine the computed values; furtherbind doCombine to generate
   * code to combine multiple boolean results.  NB: imports 'cplr1'
   * and 'cplr2' to use the two subexpression compilers generated
   * at the general level.  NB: 'stran' which describes the end result
   * is always boolean for this compiler, and it is initialized early
   * such that it can be used by subpatterns also for accumulated
   * values (in doCombine).  In case there are no results at all (as
   * with object@=object@) we invoke 'onNoResults'.
   *)
  (# stran1,stran2,resultSTran: ^staticTransient;
     coercionPos: ^betaByteCode;
     doCoerce:< binCoerceBase;
     onNoResults:< object;
     prepare::(# #);
     generate::<
       (# doCombine:< object;
          hasNext: booleanValue
            (#
            do (if true 
                // cplr1.more and cplr2.more then true->value
                // (not cplr1.more) and (not cplr2.more) then false->value
                else
                   'Operands deliver different number of values'
                     ->internalError
               if)
            #);
          hasPredecessor: @boolean (* earlier result on stack? *)
       do
          (* The result is always a boolean *)
          (&staticBooleanTransient[]).init->stran[];
          (* prepare both subcompilers *)
          (program[],cInfo[])->cplr1.prepare;
          (program[],cInfo[])->cplr2.prepare;
          (* iterate over all the values generated by the subcompilers, 
           * and accumulate the results by 'doCombine' for result
           * no. 2 and on *)
          L: (if hasNext then
                 (program[],cInfo[])
                   ->cplr1.generate
                   ->stran1[];
                 program.lastLink[]->coercionPos[];
                 (program[],cInfo[])
                   ->cplr2.generate
                   ->stran2[];
                 (program[],coercionPos[],stran1[]
                 ,stran2[],cInfo[],usageAst[])
                   ->doCoerce
                   ->resultSTran[];
                 INNER; (* compute the result based on the two stack values *)
                 (if hasPredecessor then
                     (* this is the second-or-more result, so 
                      * we must combine with older results to 
                      * produce a new accumulated result *)
                     doCombine
                  else
                     (* this is the first result, but from this
                      * point the results will be second-or-more *)
                     true->hasPredecessor
                 if);
                 restart L
              else
                 (if not hasPredecessor then
                     (* no results generated, e.g., object@=object@,
                      * so the subpattern chooses a default *)
                     onNoResults
                 if);
                 (program[],cInfo[])
                   ->cplr1.cleanup;
                 (program[],cInfo[])
                   ->cplr2.cleanup
             if)
       #);
     cleanup::(# #)
  #)

-- BinExpPrint:dopart --
do
   (dest[],indentation,false)->operand1.print;
   INNER;
   (dest[],indentation,false)->operand2.print

-- BinExpScanImpl:dopart --
do
   INNER;
   (preCB[],postCB[])->operand1.scanImpl;
   (preCB[],postCB[])->operand2.scanImpl

-- BinExpGetTranOut:dopart --
do
   (depth+1,focus[],context[]
   ,(this(l2BinExp)[],usageAst[])->addUsageAst)
     ->operand1.getStaticTransientOut
     ->operand1Transient[];
   (depth+1,focus[],context[]
   ,(this(l2BinExp)[],usageAst[])->addUsageAst)
     ->operand2.getStaticTransientOut
     ->operand2Transient[];
   INNER

-- BinExpGetTranIn:dopart --
do
   ('Attmpt to assign to a binary expression'
   ,'Don\'t',this(l2BinExp)[]->newUsageAst,NONE)->staticError

-- BinExpGetCplr:dopart --
do
   &exeCompiler
   (# cplr1: ^exitCompiler;
      cplr2: ^exitCompiler;
      stran1,stran2: ^staticTransient;
      generate::
        (# count: @integer
        do this(l2BinExp)[]
             ->newUsageAst
             ->noResultWarning;

           (focus[],context[],usageAst[])
             ->operand1.getExitCompiler
             ->cplr1[];
           (focus[],context[],usageAst[])
             ->operand2.getExitCompiler
             ->cplr2[];

           (program[],cInfo[])
             ->cplr1.prepare;
           (program[],cInfo[])
             ->cplr2.prepare;

           L: (if cplr1.more and cplr2.more then
                  (program[],cInfo[])
                    ->cplr1.generate
                    ->stran1[];
                  (program[],cInfo[])
                    ->cplr2.generate
                    ->stran2[];
                  count+1->count;

                  (* get rid of the computed values; it makes no
                   * difference whether we compute the ignored
                   * value ifself, so we don''t; NB!! this means
                   * that "1/0;" will evaluate "1" and "0" but
                   * will not give a divide-by-zero error;
                   * Also note that since NONE does not itself lead
                   * to pushed values on any stack, we must only
                   * pop for the not-NONE values *)
                  (if stran2##<>staticNoneTransient## then
                      ('ibetaTwoExprbody.bet/1305',stran2[])
                        ->(&discardCode[]).init
                        ->program.append
                  if);
                  (if stran1##<>staticNoneTransient## then
                      ('ibetaTwoExprbody.bet/1310',stran1[])
                        ->(&discardCode[]).init
                        ->program.append
                  if);

                  restart L

               else
                  (if cplr1.more<>cplr2.more then
                      (* lists have different lengths *)
                      ('Values obtained from operands have different structure'
                      ,'Use expressions that yield one value each'
                      ,(this(l2BinExp)[],usageAst[])->addUsageAst
                      ,NONE)->staticError
                  if)
              if);

           (if (count<>1) and (not allowsListTransient) then
               (* lists are not of length one *)
               (# msg: ^text
               do 'Operands yield '->msg[];
                  count->msg.putint;
                  ' values each'->msg.puttext;
                  (msg[]
                  ,'Use expressions that yield one value each'
                  ,(this(l2BinExp)[],usageAst[])->addUsageAst
                  ,NONE)->staticError
               #)
           if);

           (program[],cInfo[])
             ->cplr1.cleanup;
           (program[],cInfo[])
             ->cplr2.cleanup
        #)
   #)[]->ec[];
   usageAst[]->ec.usageAst[]

-- BinExpGetEnterCplr:dopart --
do
   ('Attempt to assign to a binary expression'
   ,'Don\'t'
   ,(this(l2BinExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- BinExpGetExitCplr:dopart --
do
   (focus[],context[],usageAst[])
     ->operand1.getExitCompiler
     ->cplr1[];
   (focus[],context[],usageAst[])
     ->operand2.getExitCompiler
     ->cplr2[];
   INNER

-- BinExpGetEnterExitCplr:dopart --
do
   ('Attempt to assign-then-evaluate a binary expression'
   ,'Don\'t'
   ,(this(l2BinExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(*************************************************************
 *                                                           *
 *                          l2EqExp                          *
 *                                                           *
 *************************************************************)

-- EqExpPrint:dopart --
do
   '='->output

-- EqExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->eqneqBinOpStaticCoercion
     ->stran[]

-- EqExpGetExitCplr:dopart --
do
   &delegate2BoolCombineExitCompiler
   (# doCoerce::binEqCoerce;
      onNoResults::
        (# do ('ibetaTwoExprbody.bet/414',true)
             ->(&literalBooleanCode[]).init
             ->program.append
        #);
      generate::
        (# doCombine::
             (# do ('ibetaTwoExprbody.bet/420',stran[])
                  ->(&mulopAndExpCode[]).init
                  ->program.append
             #)
        do ('ibetaTwoExprbody.bet/424',resultSTran[])
             ->(&relopEqExpCode[]).init
             ->program.append;
           (* NB: stran is already initialized in this kind of compiler *)
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2LtExp                          *
 *                                                           *
 *************************************************************)

-- LtExpPrint:dopart --
do
   '<'->output

-- LtExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->uneqBinOpStaticCoercion
     ->stran[]

-- LtExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binInEqCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1438',resultSTran[])
             ->(&relopLtExpCode[]).init
             ->program.append;
           (&staticBooleanTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2LeExp                          *
 *                                                           *
 *************************************************************)

-- LeExpPrint:dopart --
do
   '<='->output

-- LeExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->uneqBinOpStaticCoercion
     ->stran[]

-- LeExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binInEqCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1479',resultSTran[])
             ->(&relopLeExpCode[]).init
             ->program.append;
           (&staticBooleanTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2GtExp                          *
 *                                                           *
 *************************************************************)

-- GtExpPrint:dopart --
do
   '>'->output

-- GtExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->uneqBinOpStaticCoercion
     ->stran[]

-- GtExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binInEqCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1520',resultSTran[])
             ->(&relopGtExpCode[]).init
             ->program.append;
           (&staticBooleanTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2GeExp                          *
 *                                                           *
 *************************************************************)

-- GeExpPrint:dopart --
do
   '>='->output

-- GeExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->uneqBinOpStaticCoercion
     ->stran[]

-- GeExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binInEqCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1561',resultSTran[])
             ->(&relopGeExpCode[]).init
             ->program.append;
           (&staticBooleanTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2NeExp                          *
 *                                                           *
 *************************************************************)

-- NeExpPrint:dopart --
do
   '<>'->output

-- NeExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->eqneqBinOpStaticCoercion
     ->stran[]

-- NeExpGetExitCplr:dopart --
do
   &delegate2BoolCombineExitCompiler
   (# doCoerce::binEqCoerce;
      onNoResults::
        (# do ('ibetaTwoExprbody.bet/575',false)
             ->(&literalBooleanCode[]).init
             ->program.append
        #);
      generate::
        (# doCombine::
             (# do ('ibetaTwoExprbody.bet/581',stran[])
                  ->(&addopOrExpCode[]).init
                  ->program.append
             #)
        do ('ibetaTwoExprbody.bet/585',resultSTran[])
             ->(&relopNeExpCode[]).init
             ->program.append;
           (* NB: stran is already initialized in this kind of compiler *)
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                         l2PlusExp                         *
 *                                                           *
 *************************************************************)

-- PlusExpPrint:dopart --
do
   '+'->output

-- PlusExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->plusBinOpStaticCoercion
     ->stran[]

-- PlusExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binPlusCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1643',resultSTran[]->stran[])
             ->(&addopPlusExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                        l2MinusExp                        *
 *                                                          *
 ************************************************************)

-- MinusExpPrint:dopart --
do
   '-'->output

-- MinusExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->arithBinOpStaticCoercion
     ->stran[]

-- MinusExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binArithCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1713',resultSTran[]->stran[])
             ->(&addopMinusExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                          l2OrExp                          *
 *                                                           *
 *************************************************************)

-- OrExpPrint:dopart --
do
   ' or '->output

-- OrExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->andorBinOpStaticCoercion
     ->stran[]

-- OrExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binBoolCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1773',resultSTran[]->stran[])
             ->(&addopOrExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                         l2XorExp                         *
 *                                                          *
 ************************************************************)

-- XorExpPrint:dopart --
do
   ' xor '->output

-- XorExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->andorBinOpStaticCoercion
     ->stran[]

-- XorExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binBoolCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/1823',resultStran[]->stran[])
             ->(&addopXorExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                      l2UnaryPlusExp                      *
 *                                                          *
 ************************************************************)

-- UnaryPlusExpPrint:dopart --
do
   '+'->output

-- UnaryPlusExpGetTranOut:dopart --
do
   (operandTransient[],usageAst[]->extendUsageAst)
     ->addUnOpStaticCoercion
     ->stran[]

-- UnaryPlusExpGetCplr:dopart --
do
   &exeCompiler
   (# substran: ^staticTransient; (* only used for checking and diagnostics *)
      generate::
        (# do (program[],cInfo[])->operandCplr.prepare;
           (if operandCplr.more then
               (program[],cInfo[])
                 ->operandCplr.generate
                 ->substran[]
            else
               ('Unary plus expression yields no values'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if not operandCplr.more then
               (program[],cInfo[])->operandCplr.cleanup
            else
               ('Unary plus expression yields more than one value'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if substran##
            // staticIntegerTransient## then
               ('ibetaTwoExprbody.bet/1892'
               ,(&staticIntegerTransient[]).init)
                 ->(&discardCode[]).init
                 ->program.append
            // staticRealTransient## then
               ('ibetaTwoExprbody.bet/1896'
               ,(&staticRealTransient[]).init)
                 ->(&discardCode[]).init
                 ->program.append
            else
               (# msg: ^text
               do 'Unexpected type for unary plus expression: '
                    ->msg[];
                  substran.typename->msg.puttext;
                  (msg[]
                  ,'Use an expression of type int or float'
                  ,usageAst[],NONE)->staticError
               #)
           if)
        #)
   #)[]->ec[];
   usageAst[]->ec.usageAst[]

-- UnaryPlusExpGetExitCplr:dopart --
do
   (* unary plus makes no difference, so we could actually just do
    * 'operandCplr[]->xc[]'!  This gives better checking, though *)
   &exitOnceCompiler
   (# subxc: ^exitCompiler;
      prepare::
        (# do operandCplr[]->subxc[];
           (program[],cInfo[])->subxc.prepare
        #);
      generate::
        (# substran: ^staticTransient
        do (if subxc.more then
               (program[],cInfo[])
                 ->subxc.generate
                 ->substran[]
            else
               ('Unary plus expression yields no values'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if not subxc.more then
               (program[],cInfo[])->subxc.cleanup
            else
               ('Unary plus expression yields more than one value'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if substran##
            // staticIntegerTransient## // staticRealTransient## then
               (* OK, no new instructions needed *)
            else
               (# msg: ^text
               do 'Unexpected type for unary plus expression: '
                    ->msg[];
                  substran.typename->msg.puttext;
                  (msg[]
                  ,'Use an expression of type int or float'
                  ,usageAst[],NONE)->staticError
               #)
           if);
           substran[]->stran[]
        #);
      cleanup::(# #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                      l2UnaryMinusExp                      *
 *                                                           *
 *************************************************************)

-- UnaryMinusExpPrint:dopart --
do
   '-'->output

-- UnaryMinusExpGetTranOut:dopart --
do
   (operandTransient[],usageAst[]->extendUsageAst)
     ->addUnOpStaticCoercion
     ->stran[]

-- UnaryMinusExpGetCplr:dopart --
do
   &exeCompiler
   (# substran: ^staticTransient; (* only used for checking and diagnostics *)
      generate::
        (# do (program[],cInfo[])->operandCplr.prepare;
           (if operandCplr.more then
               (program[],cInfo[])
                 ->operandCplr.generate
                 ->substran[]
            else
               ('Unary minus expression yields no values'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if not operandCplr.more then
               (program[],cInfo[])->operandCplr.cleanup
            else
               ('Unary minus expression yields more than one value'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if substran##
            // staticIntegerTransient## then
               'ibetaTwoExprbody.bet/2017'
                 ->(&negateIntegerCode[]).init
                 ->program.append;
               ('ibetaTwoExprbody.bet/2020'
                ,(&staticIntegerTransient[]).init)
                 ->(&discardCode[]).init
                 ->program.append
            // staticRealTransient## then
               'ibetaTwoExprbody.bet/2024'
                 ->(&negateRealCode[]).init
                 ->program.append;
               ('ibetaTwoExprbody.bet/2027'
               ,(&staticRealTransient[]).init)
                 ->(&discardCode[]).init
                 ->program.append
            else
               (# msg: ^text
               do 'Unexpected type for unary minus expression: '
                    ->msg[];
                  substran.typename->msg.puttext;
                  (msg[]
                  ,'Use an expression of type int or float'
                  ,usageAst[],NONE)->staticError
               #)
           if)
        #)
   #)[]->ec[];
   usageAst[]->ec.usageAst[]

-- UnaryMinusExpGetExitCplr:dopart --
do
   &exitOnceCompiler
   (# subxc: ^exitCompiler;
      prepare::
        (# do operandCplr[]->subxc[];
           (program[],cInfo[])->subxc.prepare
        #);
      generate::
        (# substran: ^staticTransient;
        do (if subxc.more then
               (program[],cInfo[])
                 ->subxc.generate
                 ->substran[]
            else
               ('Unary minus expression yields no values'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if subxc.more then
               ('Unary minus expression yields more than one value'
               ,'Use an expression yielding an int or a float'
               ,usageAst[],NONE)->staticError
           if);
           (if substran##
            // staticIntegerTransient## then
               'ibetaTwoExprbody.bet/2072'
                 ->(&negateIntegerCode[]).init
                 ->program.append
            // staticRealTransient## then
               'ibetaTwoExprbody.bet/2076'
                 ->(&negateRealCode[]).init
                 ->program.append
            else
               (# msg: ^text
               do 'Unexpected type for unary minus expression: '
                    ->msg[];
                  substran.typename->msg.puttext;
                  (msg[]
                  ,'Use an expression of type int or float'
                  ,usageAst[],NONE)->staticError
               #)
           if);
           substran[]->stran[]
        #);
      cleanup::(# do (program[],cInfo[])->subxc.cleanup #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                        l2TimesExp                        *
 *                                                          *
 ************************************************************)

-- TimesExpPrint:dopart --
do
   '*'->output

-- TimesExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->arithBinOpStaticCoercion
     ->stran[]

-- TimesExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binArithCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/2147',resultSTran[]->stran[])
             ->(&mulopTimesExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                       l2RealDivExp                       *
 *                                                          *
 ************************************************************)

-- RealDivExpPrint:dopart --
do
   '/'->output

-- RealDivExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->rdivBinOpStaticCoercion
     ->stran[]

-- RealDivExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binRDivCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/2206',resultSTran[]->stran[])
             ->(&mulopRealDivExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                        l2IntDivExp                        *
 *                                                           *
 *************************************************************)

-- IntDivExpPrint:dopart --
do
   ' div '->output

-- IntDivExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[]
   ,usageAst[]->extendUsageAst)
     ->arithBinOpStaticCoercion
     ->stran[]

-- IntDivExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binArithCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/2263',resultSTran[]->stran[])
             ->(&mulopIntDivExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                         l2ModExp                         *
 *                                                          *
 ************************************************************)

-- ModExpPrint:dopart --
do
   ' mod '->output

-- ModExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[],usageAst[]->extendUsageAst)
     ->modBinOpStaticCoercion
     ->stran[]

-- ModExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binModCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/2328',resultSTran[]->stran[])
             ->(&mulopModExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(************************************************************
 *                                                          *
 *                         l2AndExp                         *
 *                                                          *
 ************************************************************)

-- AndExpPrint:dopart --
do
   ' and '->output

-- AndExpGetTranOut:dopart --
do
   (operand1Transient[],operand2Transient[],usageAst[]->extendUsageAst)
     ->andorBinOpStaticCoercion
     ->stran[]

-- AndExpGetExitCplr:dopart --
do
   &delegate2ExitCompiler
   (# doCoerce::binBoolCoerce;
      generate::
        (# do ('ibetaTwoExprbody.bet/2383',resultSTran[]->stran[])
             ->(&mulopAndExpCode[]).init
             ->program.append
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                        l2TextConst                        *
 *                                                           *
 *************************************************************)

-- TextConstPrint:dopart --
do
   '\''->output;
   (for i:value.length repeat value.T[i]->outputChar for);
   '\''->output

-- TextConstGetTranOut:dopart --
do
   (value.length=1)->(&staticStringTransient[]).init->stran[]

-- TextConstGetTranIn:dopart --
do
   ('Attempt to assign to a literal text'
   ,'Use a string object or similar'
   ,usageAst[]->extendUsageAst
   ,NONE)->staticError

-- TextConstGetCplr:dopart --
do
   (* it is a no-op to execute a text const *)
   &exeCompiler[]->ec[];
   usageAst[]->ec.usageAst[]

-- TextConstGetEnterCplr:dopart --
do
   ('Trying to assign to an literal text!'
   ,'Use a string object or similar'
   ,(this(l2TextConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- TextConstGetExitCplr:dopart --
do
   &exitOnceCompiler
   (# generate::
        (# do ('ibetaTwoExprbody.bet/2449',value[])
             ->(&literalStringCode[]).init
             ->program.append;
           (value.length=1)
             ->(&staticStringTransient[]).init
             ->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

-- TextConstGetEnterExitCplr:dopart --
do
   ('Trying to assign-then-evaluate a literal text!'
   ,'Use a string object or similar'
   ,(this(l2TextConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(************************************************************
 *                                                          *
 *                      l2IntegerConst                      *
 *                                                          *
 ************************************************************)

-- IntegerConstPrint:dopart --
do
   (# t: ^text
   do &text[]->t[];
      value->t.putint;
      t[]->output
   #)

-- IntegerConstGetTranOut:dopart --
do
   createSingletonTransient(# type::staticIntegerTransient #)->stran[]

-- IntegerConstGetTranIn:dopart --
do
   ('Attempt to assign to a literal int'
   ,'Use an int object or similar'
   ,usageAst[]->extendUsageAst
   ,NONE)->staticError

-- IntegerConstGetCplr:dopart --
do
   (* no-op *)
   &exeCompiler[]->ec[];
   usageAst[]->ec.usageAst[]

-- IntegerConstGetEnterCplr:dopart --
do
   ('Attempt to assign to a literal int'
   ,'Use an int object or similar'
   ,(this(l2IntegerConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- IntegerConstGetExitCplr:dopart --
do
   &exitOnceCompiler
   (# generate::
        (# do ('ibetaTwoExprbody.bet/2522',value)
             ->(&literalIntegerCode[]).init
             ->program.append;
           (&staticIntegerTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

-- IntegerConstGetEnterExitCplr:dopart --
do
   ('Attempt to assign-then-evaluate a literal int'
   ,'Use an int object or similar'
   ,(this(l2IntegerConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(*************************************************************
 *                                                           *
 *                        l2RealConst                        *
 *                                                           *
 *************************************************************)

-- RealConstPrint:dopart --
do
   (# t: ^text
   do &text[]->t[];
      value->t.putreal;
      t[]->output
   #)

-- RealConstGetTranOut:dopart --
do
   createSingletonTransient(# type::staticRealTransient #)->stran[]

-- RealConstGetTranIn:dopart --
do
   ('Attempt to assign to a literal float'
   ,'Use a float object'
   ,usageAst[]->extendUsageAst
   ,NONE)->staticError

-- RealConstGetCplr:dopart --
do
   (* no-op *)
   &exeCompiler[]->ec[];
   usageAst[]->ec.usageAst[]

-- RealConstGetEnterCplr:dopart --
do
   ('Attempt to assign to a literal float'
   ,'Use a float object'
   ,(this(l2RealConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- RealConstGetExitCplr:dopart --
do
   &exitOnceCompiler
   (# generate::
        (# do ('ibetaTwoExprbody.bet/2592',value)
             ->(&literalRealCode[]).init
             ->program.append;
           (&staticRealTransient[]).init->stran[]
        #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

-- RealConstGetEnterExitCplr:dopart --
do
   ('Attempt to assign-then-evaluate a literal float'
   ,'Use a float object'
   ,(this(l2RealConst)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(************************************************************
 *                                                          *
 *                         l2NotExp                         *
 *                                                          *
 ************************************************************)

-- NotExpPrint:dopart --
do
   ' not '->output

-- NotExpGetTranOut:dopart --
do
   (operandTransient[],usageAst[]->extendUsageAst)
     ->notUnOpStaticCoercion
     ->stran[]

-- NotExpGetExitCplr:dopart --
do
   &exitOnceCompiler
   (# done: @boolean;
      subxc: ^exitCompiler;
      prepare::
        (# do (focus[],context[],usageAst[])
             ->operand.getExitCompiler
             ->subxc[];
           (program[],cInfo[])->subxc.prepare
        #);
      generate::
        (# substran: ^staticTransient
        do (if subxc.more then
               (program[],cInfo[])->subxc.generate->substran[]
            else
               ('Not-expression does not yield any values'
               ,'Use an expression of type boolean'
               ,(this(l2NotExp)[],usageAst[])->addUsageAst
               ,NONE)->staticError
           if);
           (if not subxc.more then
               (program[],cInfo[])->subxc.cleanup
            else
               ('Not-expression yields more than one value'
               ,'Use an expression of type boolean'
               ,(this(l2NotExp)[],usageAst[])->addUsageAst
               ,NONE)->staticError
           if);
           (if substran##<>staticBooleanTransient## then
               (# msg: ^text
               do 'Not-expression yields value of type '->msg[];
                  substran.typename->msg.puttext;
                  (msg[]
                  ,'Use an expression of type boolean'
                  ,(this(l2NotExp)[],usageAst[])->addUsageAst
                  ,NONE)->staticError
               #)
           if);
           'ibetaTwoExprbody.bet/2675'
             ->(&negateBooleanCode[]).init
             ->program.append;
           (&staticBooleanTransient[]).init->stran[]
        #);
      cleanup::(# #)
   #)[]->xc[];
   usageAst[]->xc.usageAst[]

(*************************************************************
 *                                                           *
 *                         l2NoneExp                         *
 *                                                           *
 *************************************************************)

-- NoneExpPrint:dopart --
do
   'null'->output

-- NoneExtGetTranOut:dopart --
do
   createSingletonTransient(# type::staticNoneTransient #)->stran[]

-- NoneExpGetTranIn:dopart --
do
   ('Attempt to assign to a literal null'
   ,'Use an object reference or a pattern reference'
   ,usageAst[]->extendUsageAst
   ,NONE)->staticError

-- NoneExpGetCplr:dopart --
do
   (* no-op *)
   &exeCompiler[]->ec[];
   usageAst[]->ec.usageAst[]

-- NoneExpGetEnterCplr:dopart --
do
   ('Attempt to assign to a literal null'
   ,'Use an object reference or a pattern reference'
   ,(this(l2NoneExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

-- NoneExpGetExitCplr:dopart --
do
   (* NB: no bytecodes generated here, coercion will select oref or ptn.
    * So this expression does _not_ make any stacks higher! *)
   &exitOnceCompiler
   (# generate::(# do (&staticNoneTransient[]).init->stran[] #)#)[]->xc[];
   usageAst[]->xc.usageAst[]

-- NoneExpGetEnterExitCplr:dopart --
do
   ('Attempt to assign-then-evaluate a literal null'
   ,'Use an object reference or a pattern reference'
   ,(this(l2NoneExp)[],usageAst[])->addUsageAst
   ,NONE)->staticError

(*
 * local variables:
 * ee-beta-main-file: "/src/main/gbeta.bet"
 * end:
 *)
