ORIGIN 'gbetacfl';
BODY 'gbetatraversebody';

(* Skeleton file for traversal of ASTs based on
 * grammar 'gbeta'.
 * Take a copy of this file and fill out the do-parts.
 * Do NOT edit this file directly as it will be overwritten
 * when the grammar is processed again.
 *)
--LIB: attributes--

gbeta_traverse: 
  (# ast: @astInterface (* An instance of the AST interface *);
     gbeta: @ast.gbeta;

     do_DescriptorForm: (* cons *)
       (# D: ^gbeta.DescriptorForm
       enter D[]
       <<SLOT do_DescriptorForm_body: DoPart>>
       #);
     do_Descriptor: (* cons *)
       (# D: ^gbeta.Descriptor
       enter D[]
       <<SLOT do_Descriptor_body: DoPart>>
       #);
     do_PrefixOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_PrefixOpt_body: DoPart>>
       #);
     do_Prefix: (* cons *)
       (# P: ^gbeta.Prefix
       enter P[]
       <<SLOT do_Prefix_body: DoPart>>
       #);
     do_DescriptorTails: (* list *)
       (# D: ^gbeta.DescriptorTails
       enter D[]
       <<SLOT do_DescriptorTails_body: DoPart>>
       #);
     do_DescriptorTail: (* cons *)
       (# D: ^gbeta.DescriptorTail
       enter D[]
       <<SLOT do_DescriptorTail_body: DoPart>>
       #);
     do_MainPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_MainPartOpt_body: DoPart>>
       #);
     do_MainPart: (* alternation *)
       (# M: ^gbeta.MainPart
       enter M[]
       <<SLOT do_MainPart_body: DoPart>>
       #);
     do_ArgMPar: (* cons *)
       (# A: ^gbeta.ArgMPar
       enter A[]
       <<SLOT do_ArgMPar_body: DoPart>>
       #);
     do_NoArgMPar: (* cons *)
       (# N: ^gbeta.NoArgMPar
       enter N[]
       <<SLOT do_NoArgMPar_body: DoPart>>
       #);
     do_NoBlkMPar: (* cons *)
       (# N: ^gbeta.NoBlkMPar
       enter N[]
       <<SLOT do_NoBlkMPar_body: DoPart>>
       #);
     do_Block: (* alternation *)
       (# B: ^gbeta.Block
       enter B[]
       <<SLOT do_Block_body: DoPart>>
       #);
     do_AttBlock: (* cons *)
       (# A: ^gbeta.AttBlock
       enter A[]
       <<SLOT do_AttBlock_body: DoPart>>
       #);
     do_StmBlock: (* cons *)
       (# S: ^gbeta.StmBlock
       enter S[]
       <<SLOT do_StmBlock_body: DoPart>>
       #);
     do_EmtBlock: (* cons *)
       (# E: ^gbeta.EmtBlock
       enter E[]
       <<SLOT do_EmtBlock_body: DoPart>>
       #);
     do_BlockEnd: (* alternation *)
       (# B: ^gbeta.BlockEnd
       enter B[]
       <<SLOT do_BlockEnd_body: DoPart>>
       #);
     do_RBrace: (* cons *)
       (# R: ^gbeta.RBrace
       enter R[]
       <<SLOT do_RBrace_body: DoPart>>
       #);
     do_EvalRBrace: (* cons *)
       (# E: ^gbeta.EvalRBrace
       enter E[]
       <<SLOT do_EvalRBrace_body: DoPart>>
       #);
     do_Args: (* alternation *)
       (# A: ^gbeta.Args
       enter A[]
       <<SLOT do_Args_body: DoPart>>
       #);
     do_ArgsNormal: (* cons *)
       (# A: ^gbeta.ArgsNormal
       enter A[]
       <<SLOT do_ArgsNormal_body: DoPart>>
       #);
     do_ArgsReturn: (* cons *)
       (# A: ^gbeta.ArgsReturn
       enter A[]
       <<SLOT do_ArgsReturn_body: DoPart>>
       #);
     do_ArgList: (* list *)
       (# A: ^gbeta.ArgList
       enter A[]
       <<SLOT do_ArgList_body: DoPart>>
       #);
     do_Arg: (* alternation *)
       (# A: ^gbeta.Arg
       enter A[]
       <<SLOT do_Arg_body: DoPart>>
       #);
     do_ArgEval: (* cons *)
       (# A: ^gbeta.ArgEval
       enter A[]
       <<SLOT do_ArgEval_body: DoPart>>
       #);
     do_ArgDecl: (* cons *)
       (# A: ^gbeta.ArgDecl
       enter A[]
       <<SLOT do_ArgDecl_body: DoPart>>
       #);
     do_ArgRHS: (* alternation *)
       (# A: ^gbeta.ArgRHS
       enter A[]
       <<SLOT do_ArgRHS_body: DoPart>>
       #);
     do_ExitsOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ExitsOpt_body: DoPart>>
       #);
     do_Exits: (* cons *)
       (# E: ^gbeta.Exits
       enter E[]
       <<SLOT do_Exits_body: DoPart>>
       #);
     do_Declarations: (* cons *)
       (# D: ^gbeta.Declarations
       enter D[]
       <<SLOT do_Declarations_body: DoPart>>
       #);
     do_Attributes: (* list *)
       (# A: ^gbeta.Attributes
       enter A[]
       <<SLOT do_Attributes_body: DoPart>>
       #);
     do_DoPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DoPartOpt_body: DoPart>>
       #);
     do_DoPart: (* cons *)
       (# D: ^gbeta.DoPart
       enter D[]
       <<SLOT do_DoPart_body: DoPart>>
       #);
     do_PubMarkOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_PubMarkOpt_body: DoPart>>
       #);
     do_PubMark: (* cons *)
       (# P: ^gbeta.PubMark
       enter P[]
       <<SLOT do_PubMark_body: DoPart>>
       #);
     do_MainPartSep: (* cons *)
       (# M: ^gbeta.MainPartSep
       enter M[]
       <<SLOT do_MainPartSep_body: DoPart>>
       #);
     do_AttributeDecl: (* cons *)
       (# A: ^gbeta.AttributeDecl
       enter A[]
       <<SLOT do_AttributeDecl_body: DoPart>>
       #);
     do_NamesOrOp: (* alternation *)
       (# N: ^gbeta.NamesOrOp
       enter N[]
       <<SLOT do_NamesOrOp_body: DoPart>>
       #);
     do_Names: (* cons *)
       (# N: ^gbeta.Names
       enter N[]
       <<SLOT do_Names_body: DoPart>>
       #);
     do_NameDcls: (* list *)
       (# N: ^gbeta.NameDcls
       enter N[]
       <<SLOT do_NameDcls_body: DoPart>>
       #);
     do_OpSpec: (* cons *)
       (# O: ^gbeta.OpSpec
       enter O[]
       <<SLOT do_OpSpec_body: DoPart>>
       #);
     do_PathCstrOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_PathCstrOpt_body: DoPart>>
       #);
     do_PathCstr: (* cons *)
       (# P: ^gbeta.PathCstr
       enter P[]
       <<SLOT do_PathCstr_body: DoPart>>
       #);
     do_AttributeRHS: (* alternation *)
       (# A: ^gbeta.AttributeRHS
       enter A[]
       <<SLOT do_AttributeRHS_body: DoPart>>
       #);
     do_DefaultRHS: (* cons *)
       (# D: ^gbeta.DefaultRHS
       enter D[]
       <<SLOT do_DefaultRHS_body: DoPart>>
       #);
     do_SimpleRHS: (* cons *)
       (# S: ^gbeta.SimpleRHS
       enter S[]
       <<SLOT do_SimpleRHS_body: DoPart>>
       #);
     do_RepetitionRHS: (* cons *)
       (# R: ^gbeta.RepetitionRHS
       enter R[]
       <<SLOT do_RepetitionRHS_body: DoPart>>
       #);
     do_PatternRHS: (* cons *)
       (# P: ^gbeta.PatternRHS
       enter P[]
       <<SLOT do_PatternRHS_body: DoPart>>
       #);
     do_PtnExtRHS: (* cons *)
       (# P: ^gbeta.PtnExtRHS
       enter P[]
       <<SLOT do_PtnExtRHS_body: DoPart>>
       #);
     do_VPatternRHS: (* cons *)
       (# V: ^gbeta.VPatternRHS
       enter V[]
       <<SLOT do_VPatternRHS_body: DoPart>>
       #);
     do_OwnerAssocRHS: (* cons *)
       (# O: ^gbeta.OwnerAssocRHS
       enter O[]
       <<SLOT do_OwnerAssocRHS_body: DoPart>>
       #);
     do_SlaveAssocRHS: (* cons *)
       (# S: ^gbeta.SlaveAssocRHS
       enter S[]
       <<SLOT do_SlaveAssocRHS_body: DoPart>>
       #);
     do_ArgDefaultRHS: (* cons *)
       (# A: ^gbeta.ArgDefaultRHS
       enter A[]
       <<SLOT do_ArgDefaultRHS_body: DoPart>>
       #);
     do_ArgSimpleRHS: (* cons *)
       (# A: ^gbeta.ArgSimpleRHS
       enter A[]
       <<SLOT do_ArgSimpleRHS_body: DoPart>>
       #);
     do_ArgRepRHS: (* cons *)
       (# A: ^gbeta.ArgRepRHS
       enter A[]
       <<SLOT do_ArgRepRHS_body: DoPart>>
       #);
     do_SwapOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_SwapOpt_body: DoPart>>
       #);
     do_Swap: (* cons *)
       (# S: ^gbeta.Swap
       enter S[]
       <<SLOT do_Swap_body: DoPart>>
       #);
     do_RestrictionOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_RestrictionOpt_body: DoPart>>
       #);
     do_RestrictionPart: (* cons *)
       (# R: ^gbeta.RestrictionPart
       enter R[]
       <<SLOT do_RestrictionPart_body: DoPart>>
       #);
     do_Restrictions: (* list *)
       (# R: ^gbeta.Restrictions
       enter R[]
       <<SLOT do_Restrictions_body: DoPart>>
       #);
     do_Restriction: (* cons *)
       (# R: ^gbeta.Restriction
       enter R[]
       <<SLOT do_Restriction_body: DoPart>>
       #);
     do_ReferenceSpec: (* alternation *)
       (# R: ^gbeta.ReferenceSpec
       enter R[]
       <<SLOT do_ReferenceSpec_body: DoPart>>
       #);
     do_StaticItem: (* cons *)
       (# S: ^gbeta.StaticItem
       enter S[]
       <<SLOT do_StaticItem_body: DoPart>>
       #);
     do_VirtualStaticItem: (* cons *)
       (# V: ^gbeta.VirtualStaticItem
       enter V[]
       <<SLOT do_VirtualStaticItem_body: DoPart>>
       #);
     do_FinalStaticItem: (* cons *)
       (# F: ^gbeta.FinalStaticItem
       enter F[]
       <<SLOT do_FinalStaticItem_body: DoPart>>
       #);
     do_DynamicItem: (* cons *)
       (# D: ^gbeta.DynamicItem
       enter D[]
       <<SLOT do_DynamicItem_body: DoPart>>
       #);
     do_VariablePattern: (* cons *)
       (# V: ^gbeta.VariablePattern
       enter V[]
       <<SLOT do_VariablePattern_body: DoPart>>
       #);
     do_DisownOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DisownOpt_body: DoPart>>
       #);
     do_Disown: (* cons *)
       (# D: ^gbeta.Disown
       enter D[]
       <<SLOT do_Disown_body: DoPart>>
       #);
     do_CoersOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_CoersOpt_body: DoPart>>
       #);
     do_Coers: (* alternation *)
       (# C: ^gbeta.Coers
       enter C[]
       <<SLOT do_Coers_body: DoPart>>
       #);
     do_OneCoercion: (* cons *)
       (# O: ^gbeta.OneCoercion
       enter O[]
       <<SLOT do_OneCoercion_body: DoPart>>
       #);
     do_TwoCoercion: (* cons *)
       (# T: ^gbeta.TwoCoercion
       enter T[]
       <<SLOT do_TwoCoercion_body: DoPart>>
       #);
     do_Coercion: (* alternation *)
       (# C: ^gbeta.Coercion
       enter C[]
       <<SLOT do_Coercion_body: DoPart>>
       #);
     do_CoercionRef: (* cons *)
       (# C: ^gbeta.CoercionRef
       enter C[]
       <<SLOT do_CoercionRef_body: DoPart>>
       #);
     do_CoercionVal: (* cons *)
       (# C: ^gbeta.CoercionVal
       enter C[]
       <<SLOT do_CoercionVal_body: DoPart>>
       #);
     do_CoercionPtn: (* cons *)
       (# C: ^gbeta.CoercionPtn
       enter C[]
       <<SLOT do_CoercionPtn_body: DoPart>>
       #);
     do_ObjMarkOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ObjMarkOpt_body: DoPart>>
       #);
     do_PtnMarkOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_PtnMarkOpt_body: DoPart>>
       #);
     do_ObjMark: (* cons *)
       (# O: ^gbeta.ObjMark
       enter O[]
       <<SLOT do_ObjMark_body: DoPart>>
       #);
     do_PtnMark: (* cons *)
       (# P: ^gbeta.PtnMark
       enter P[]
       <<SLOT do_PtnMark_body: DoPart>>
       #);
     do_VarMark: (* cons *)
       (# V: ^gbeta.VarMark
       enter V[]
       <<SLOT do_VarMark_body: DoPart>>
       #);
     do_ExactOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ExactOpt_body: DoPart>>
       #);
     do_Exact: (* cons *)
       (# E: ^gbeta.Exact
       enter E[]
       <<SLOT do_Exact_body: DoPart>>
       #);
     do_Type: (* cons *)
       (# T: ^gbeta.Type
       enter T[]
       <<SLOT do_Type_body: DoPart>>
       #);
     do_ConstraintPartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ConstraintPartOpt_body: DoPart>>
       #);
     do_ConstraintPart: (* cons *)
       (# C: ^gbeta.ConstraintPart
       enter C[]
       <<SLOT do_ConstraintPart_body: DoPart>>
       #);
     do_Constraints: (* list *)
       (# C: ^gbeta.Constraints
       enter C[]
       <<SLOT do_Constraints_body: DoPart>>
       #);
     do_Constraint: (* alternation *)
       (# C: ^gbeta.Constraint
       enter C[]
       <<SLOT do_Constraint_body: DoPart>>
       #);
     do_AnonymousCst: (* cons *)
       (# A: ^gbeta.AnonymousCst
       enter A[]
       <<SLOT do_AnonymousCst_body: DoPart>>
       #);
     do_NamedCst: (* cons *)
       (# N: ^gbeta.NamedCst
       enter N[]
       <<SLOT do_NamedCst_body: DoPart>>
       #);
     do_CstOperator: (* alternation *)
       (# C: ^gbeta.CstOperator
       enter C[]
       <<SLOT do_CstOperator_body: DoPart>>
       #);
     do_CstSub: (* cons *)
       (# C: ^gbeta.CstSub
       enter C[]
       <<SLOT do_CstSub_body: DoPart>>
       #);
     do_CstSuper: (* cons *)
       (# C: ^gbeta.CstSuper
       enter C[]
       <<SLOT do_CstSuper_body: DoPart>>
       #);
     do_CstEqual: (* cons *)
       (# C: ^gbeta.CstEqual
       enter C[]
       <<SLOT do_CstEqual_body: DoPart>>
       #);
     do_Statements: (* cons *)
       (# S: ^gbeta.Statements
       enter S[]
       <<SLOT do_Statements_body: DoPart>>
       #);
     do_Imps: (* list *)
       (# I: ^gbeta.Imps
       enter I[]
       <<SLOT do_Imps_body: DoPart>>
       #);
     do_SemiOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_SemiOpt_body: DoPart>>
       #);
     do_Semi: (* cons *)
       (# S: ^gbeta.Semi
       enter S[]
       <<SLOT do_Semi_body: DoPart>>
       #);
     do_Imp: (* alternation *)
       (# I: ^gbeta.Imp
       enter I[]
       <<SLOT do_Imp_body: DoPart>>
       #);
     do_LabelledImp: (* cons *)
       (# L: ^gbeta.LabelledImp
       enter L[]
       <<SLOT do_LabelledImp_body: DoPart>>
       #);
     do_LeaveImp: (* cons *)
       (# L: ^gbeta.LeaveImp
       enter L[]
       <<SLOT do_LeaveImp_body: DoPart>>
       #);
     do_RestartImp: (* cons *)
       (# R: ^gbeta.RestartImp
       enter R[]
       <<SLOT do_RestartImp_body: DoPart>>
       #);
     do_InnerImp: (* cons *)
       (# I: ^gbeta.InnerImp
       enter I[]
       <<SLOT do_InnerImp_body: DoPart>>
       #);
     do_SuspendImp: (* cons *)
       (# S: ^gbeta.SuspendImp
       enter S[]
       <<SLOT do_SuspendImp_body: DoPart>>
       #);
     do_ScopeSpecOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ScopeSpecOpt_body: DoPart>>
       #);
     do_ScopeSpec: (* alternation *)
       (# S: ^gbeta.ScopeSpec
       enter S[]
       <<SLOT do_ScopeSpec_body: DoPart>>
       #);
     do_IntScopeSpec: (* cons *)
       (# I: ^gbeta.IntScopeSpec
       enter I[]
       <<SLOT do_IntScopeSpec_body: DoPart>>
       #);
     do_NamScopeSpec: (* cons *)
       (# N: ^gbeta.NamScopeSpec
       enter N[]
       <<SLOT do_NamScopeSpec_body: DoPart>>
       #);
     do_Index: (* alternation *)
       (# I: ^gbeta.Index
       enter I[]
       <<SLOT do_Index_body: DoPart>>
       #);
     do_SimpleIndex: (* cons *)
       (# S: ^gbeta.SimpleIndex
       enter S[]
       <<SLOT do_SimpleIndex_body: DoPart>>
       #);
     do_NamedIndex: (* cons *)
       (# N: ^gbeta.NamedIndex
       enter N[]
       <<SLOT do_NamedIndex_body: DoPart>>
       #);
     do_ForImp: (* cons *)
       (# F: ^gbeta.ForImp
       enter F[]
       <<SLOT do_ForImp_body: DoPart>>
       #);
     do_WhileImp: (* cons *)
       (# W: ^gbeta.WhileImp
       enter W[]
       <<SLOT do_WhileImp_body: DoPart>>
       #);
     do_SimpleIfImp: (* cons *)
       (# S: ^gbeta.SimpleIfImp
       enter S[]
       <<SLOT do_SimpleIfImp_body: DoPart>>
       #);
     do_GeneralIfImp: (* cons *)
       (# G: ^gbeta.GeneralIfImp
       enter G[]
       <<SLOT do_GeneralIfImp_body: DoPart>>
       #);
     do_WhenImp: (* cons *)
       (# W: ^gbeta.WhenImp
       enter W[]
       <<SLOT do_WhenImp_body: DoPart>>
       #);
     do_Alts: (* list *)
       (# A: ^gbeta.Alts
       enter A[]
       <<SLOT do_Alts_body: DoPart>>
       #);
     do_Alternative: (* cons *)
       (# A: ^gbeta.Alternative
       enter A[]
       <<SLOT do_Alternative_body: DoPart>>
       #);
     do_Selections: (* list *)
       (# S: ^gbeta.Selections
       enter S[]
       <<SLOT do_Selections_body: DoPart>>
       #);
     do_Selection: (* cons *)
       (# S: ^gbeta.Selection
       enter S[]
       <<SLOT do_Selection_body: DoPart>>
       #);
     do_WhenAlts: (* list *)
       (# W: ^gbeta.WhenAlts
       enter W[]
       <<SLOT do_WhenAlts_body: DoPart>>
       #);
     do_WhenAlternative: (* cons *)
       (# W: ^gbeta.WhenAlternative
       enter W[]
       <<SLOT do_WhenAlternative_body: DoPart>>
       #);
     do_ElsePartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ElsePartOpt_body: DoPart>>
       #);
     do_ElsePart: (* cons *)
       (# E: ^gbeta.ElsePart
       enter E[]
       <<SLOT do_ElsePart_body: DoPart>>
       #);
     do_Evaluations: (* list *)
       (# E: ^gbeta.Evaluations
       enter E[]
       <<SLOT do_Evaluations_body: DoPart>>
       #);
     do_Evaluation: (* alternation *)
       (# E: ^gbeta.Evaluation
       enter E[]
       <<SLOT do_Evaluation_body: DoPart>>
       #);
     do_Assignment: (* cons *)
       (# A: ^gbeta.Assignment
       enter A[]
       <<SLOT do_Assignment_body: DoPart>>
       #);
     do_EvalOp: (* cons *)
       (# E: ^gbeta.EvalOp
       enter E[]
       <<SLOT do_EvalOp_body: DoPart>>
       #);
     do_Transaction: (* alternation *)
       (# T: ^gbeta.Transaction
       enter T[]
       <<SLOT do_Transaction_body: DoPart>>
       #);
     do_Reference: (* alternation *)
       (# R: ^gbeta.Reference
       enter R[]
       <<SLOT do_Reference_body: DoPart>>
       #);
     do_ObjectDenotation: (* cons *)
       (# O: ^gbeta.ObjectDenotation
       enter O[]
       <<SLOT do_ObjectDenotation_body: DoPart>>
       #);
     do_ComputedObjectEvaluation: (* cons *)
       (# C: ^gbeta.ComputedObjectEvaluation
       enter C[]
       <<SLOT do_ComputedObjectEvaluation_body: DoPart>>
       #);
     do_ComputedObjectEvalList: (* cons *)
       (# C: ^gbeta.ComputedObjectEvalList
       enter C[]
       <<SLOT do_ComputedObjectEvalList_body: DoPart>>
       #);
     do_ObjectReference: (* cons *)
       (# O: ^gbeta.ObjectReference
       enter O[]
       <<SLOT do_ObjectReference_body: DoPart>>
       #);
     do_ObjectValue: (* cons *)
       (# O: ^gbeta.ObjectValue
       enter O[]
       <<SLOT do_ObjectValue_body: DoPart>>
       #);
     do_ThisReference: (* cons *)
       (# T: ^gbeta.ThisReference
       enter T[]
       <<SLOT do_ThisReference_body: DoPart>>
       #);
     do_StructureReference: (* cons *)
       (# S: ^gbeta.StructureReference
       enter S[]
       <<SLOT do_StructureReference_body: DoPart>>
       #);
     do_EvalList: (* cons *)
       (# E: ^gbeta.EvalList
       enter E[]
       <<SLOT do_EvalList_body: DoPart>>
       #);
     do_DynamicObjectGeneration: (* cons *)
       (# D: ^gbeta.DynamicObjectGeneration
       enter D[]
       <<SLOT do_DynamicObjectGeneration_body: DoPart>>
       #);
     do_SimpleIfEval: (* cons *)
       (# S: ^gbeta.SimpleIfEval
       enter S[]
       <<SLOT do_SimpleIfEval_body: DoPart>>
       #);
     do_Merge: (* list *)
       (# M: ^gbeta.Merge
       enter M[]
       <<SLOT do_Merge_body: DoPart>>
       #);
     do_ObjectSpec: (* alternation *)
       (# O: ^gbeta.ObjectSpec
       enter O[]
       <<SLOT do_ObjectSpec_body: DoPart>>
       #);
     do_AttributeDenotation: (* alternation *)
       (# A: ^gbeta.AttributeDenotation
       enter A[]
       <<SLOT do_AttributeDenotation_body: DoPart>>
       #);
     do_Remote: (* cons *)
       (# R: ^gbeta.Remote
       enter R[]
       <<SLOT do_Remote_body: DoPart>>
       #);
     do_ComputedAttr: (* cons *)
       (# C: ^gbeta.ComputedAttr
       enter C[]
       <<SLOT do_ComputedAttr_body: DoPart>>
       #);
     do_ThisObject: (* cons *)
       (# T: ^gbeta.ThisObject
       enter T[]
       <<SLOT do_ThisObject_body: DoPart>>
       #);
     do_QualifiedAttrDen: (* cons *)
       (# Q: ^gbeta.QualifiedAttrDen
       enter Q[]
       <<SLOT do_QualifiedAttrDen_body: DoPart>>
       #);
     do_RemoteHead: (* alternation *)
       (# R: ^gbeta.RemoteHead
       enter R[]
       <<SLOT do_RemoteHead_body: DoPart>>
       #);
     do_RAttDeno: (* cons *)
       (# R: ^gbeta.RAttDeno
       enter R[]
       <<SLOT do_RAttDeno_body: DoPart>>
       #);
     do_REvalList: (* cons *)
       (# R: ^gbeta.REvalList
       enter R[]
       <<SLOT do_REvalList_body: DoPart>>
       #);
     do_RTextConst: (* cons *)
       (# R: ^gbeta.RTextConst
       enter R[]
       <<SLOT do_RTextConst_body: DoPart>>
       #);
     do_RIntegerConst: (* cons *)
       (# R: ^gbeta.RIntegerConst
       enter R[]
       <<SLOT do_RIntegerConst_body: DoPart>>
       #);
     do_Expression: (* alternation *)
       (# E: ^gbeta.Expression
       enter E[]
       <<SLOT do_Expression_body: DoPart>>
       #);
     do_RelationalExp: (* alternation *)
       (# R: ^gbeta.RelationalExp
       enter R[]
       <<SLOT do_RelationalExp_body: DoPart>>
       #);
     do_SimpleExp: (* alternation *)
       (# S: ^gbeta.SimpleExp
       enter S[]
       <<SLOT do_SimpleExp_body: DoPart>>
       #);
     do_AddExp: (* alternation *)
       (# A: ^gbeta.AddExp
       enter A[]
       <<SLOT do_AddExp_body: DoPart>>
       #);
     do_SignedTerm: (* alternation *)
       (# S: ^gbeta.SignedTerm
       enter S[]
       <<SLOT do_SignedTerm_body: DoPart>>
       #);
     do_Term: (* alternation *)
       (# T: ^gbeta.Term
       enter T[]
       <<SLOT do_Term_body: DoPart>>
       #);
     do_MulExp: (* alternation *)
       (# M: ^gbeta.MulExp
       enter M[]
       <<SLOT do_MulExp_body: DoPart>>
       #);
     do_EqExp: (* cons *)
       (# E: ^gbeta.EqExp
       enter E[]
       <<SLOT do_EqExp_body: DoPart>>
       #);
     do_LtExp: (* cons *)
       (# L: ^gbeta.LtExp
       enter L[]
       <<SLOT do_LtExp_body: DoPart>>
       #);
     do_LeExp: (* cons *)
       (# L: ^gbeta.LeExp
       enter L[]
       <<SLOT do_LeExp_body: DoPart>>
       #);
     do_GtExp: (* cons *)
       (# G: ^gbeta.GtExp
       enter G[]
       <<SLOT do_GtExp_body: DoPart>>
       #);
     do_GeExp: (* cons *)
       (# G: ^gbeta.GeExp
       enter G[]
       <<SLOT do_GeExp_body: DoPart>>
       #);
     do_NeExp: (* cons *)
       (# N: ^gbeta.NeExp
       enter N[]
       <<SLOT do_NeExp_body: DoPart>>
       #);
     do_PlusExp: (* cons *)
       (# P: ^gbeta.PlusExp
       enter P[]
       <<SLOT do_PlusExp_body: DoPart>>
       #);
     do_MinusExp: (* cons *)
       (# M: ^gbeta.MinusExp
       enter M[]
       <<SLOT do_MinusExp_body: DoPart>>
       #);
     do_OrExp: (* cons *)
       (# O: ^gbeta.OrExp
       enter O[]
       <<SLOT do_OrExp_body: DoPart>>
       #);
     do_XorExp: (* cons *)
       (# X: ^gbeta.XorExp
       enter X[]
       <<SLOT do_XorExp_body: DoPart>>
       #);
     do_UnaryPlusExp: (* cons *)
       (# U: ^gbeta.UnaryPlusExp
       enter U[]
       <<SLOT do_UnaryPlusExp_body: DoPart>>
       #);
     do_UnaryMinusExp: (* cons *)
       (# U: ^gbeta.UnaryMinusExp
       enter U[]
       <<SLOT do_UnaryMinusExp_body: DoPart>>
       #);
     do_TimesExp: (* cons *)
       (# T: ^gbeta.TimesExp
       enter T[]
       <<SLOT do_TimesExp_body: DoPart>>
       #);
     do_RealDivExp: (* cons *)
       (# R: ^gbeta.RealDivExp
       enter R[]
       <<SLOT do_RealDivExp_body: DoPart>>
       #);
     do_IntDivExp: (* cons *)
       (# I: ^gbeta.IntDivExp
       enter I[]
       <<SLOT do_IntDivExp_body: DoPart>>
       #);
     do_ModExp: (* cons *)
       (# M: ^gbeta.ModExp
       enter M[]
       <<SLOT do_ModExp_body: DoPart>>
       #);
     do_AndExp: (* cons *)
       (# A: ^gbeta.AndExp
       enter A[]
       <<SLOT do_AndExp_body: DoPart>>
       #);
     do_UserDefExp: (* cons *)
       (# U: ^gbeta.UserDefExp
       enter U[]
       <<SLOT do_UserDefExp_body: DoPart>>
       #);
     do_Factor: (* alternation *)
       (# F: ^gbeta.Factor
       enter F[]
       <<SLOT do_Factor_body: DoPart>>
       #);
     do_VectorLiteral: (* cons *)
       (# V: ^gbeta.VectorLiteral
       enter V[]
       <<SLOT do_VectorLiteral_body: DoPart>>
       #);
     do_VectorElms: (* list *)
       (# V: ^gbeta.VectorElms
       enter V[]
       <<SLOT do_VectorElms_body: DoPart>>
       #);
     do_VectorElm: (* cons *)
       (# V: ^gbeta.VectorElm
       enter V[]
       <<SLOT do_VectorElm_body: DoPart>>
       #);
     do_UserDefOp: (* alternation *)
       (# U: ^gbeta.UserDefOp
       enter U[]
       <<SLOT do_UserDefOp_body: DoPart>>
       #);
     do_AttDenotationOp: (* cons *)
       (# A: ^gbeta.AttDenotationOp
       enter A[]
       <<SLOT do_AttDenotationOp_body: DoPart>>
       #);
     do_UserSymOp: (* cons *)
       (# U: ^gbeta.UserSymOp
       enter U[]
       <<SLOT do_UserSymOp_body: DoPart>>
       #);
     do_UserOpSymbols: (* list *)
       (# U: ^gbeta.UserOpSymbols
       enter U[]
       <<SLOT do_UserOpSymbols_body: DoPart>>
       #);
     do_UserOpSymbol: (* alternation *)
       (# U: ^gbeta.UserOpSymbol
       enter U[]
       <<SLOT do_UserOpSymbol_body: DoPart>>
       #);
     do_PlusOp: (* cons *)
       (# P: ^gbeta.PlusOp
       enter P[]
       <<SLOT do_PlusOp_body: DoPart>>
       #);
     do_MinusOp: (* cons *)
       (# M: ^gbeta.MinusOp
       enter M[]
       <<SLOT do_MinusOp_body: DoPart>>
       #);
     do_TimesOp: (* cons *)
       (# T: ^gbeta.TimesOp
       enter T[]
       <<SLOT do_TimesOp_body: DoPart>>
       #);
     do_DivOp: (* cons *)
       (# D: ^gbeta.DivOp
       enter D[]
       <<SLOT do_DivOp_body: DoPart>>
       #);
     do_GtOp: (* cons *)
       (# G: ^gbeta.GtOp
       enter G[]
       <<SLOT do_GtOp_body: DoPart>>
       #);
     do_LtOp: (* cons *)
       (# L: ^gbeta.LtOp
       enter L[]
       <<SLOT do_LtOp_body: DoPart>>
       #);
     do_EqOp: (* cons *)
       (# E: ^gbeta.EqOp
       enter E[]
       <<SLOT do_EqOp_body: DoPart>>
       #);
     do_AndOp: (* cons *)
       (# A: ^gbeta.AndOp
       enter A[]
       <<SLOT do_AndOp_body: DoPart>>
       #);
     do_OrOp: (* cons *)
       (# O: ^gbeta.OrOp
       enter O[]
       <<SLOT do_OrOp_body: DoPart>>
       #);
     do_BangOp: (* cons *)
       (# B: ^gbeta.BangOp
       enter B[]
       <<SLOT do_BangOp_body: DoPart>>
       #);
     do_PeriodOp: (* cons *)
       (# P: ^gbeta.PeriodOp
       enter P[]
       <<SLOT do_PeriodOp_body: DoPart>>
       #);
     do_CommaOp: (* cons *)
       (# C: ^gbeta.CommaOp
       enter C[]
       <<SLOT do_CommaOp_body: DoPart>>
       #);
     do_ColonOp: (* cons *)
       (# C: ^gbeta.ColonOp
       enter C[]
       <<SLOT do_ColonOp_body: DoPart>>
       #);
     do_SemiOp: (* cons *)
       (# S: ^gbeta.SemiOp
       enter S[]
       <<SLOT do_SemiOp_body: DoPart>>
       #);
     do_ObjOp: (* cons *)
       (# O: ^gbeta.ObjOp
       enter O[]
       <<SLOT do_ObjOp_body: DoPart>>
       #);
     do_PtnOp: (* cons *)
       (# P: ^gbeta.PtnOp
       enter P[]
       <<SLOT do_PtnOp_body: DoPart>>
       #);
     do_VarOp: (* cons *)
       (# V: ^gbeta.VarOp
       enter V[]
       <<SLOT do_VarOp_body: DoPart>>
       #);
     do_DollarOp: (* cons *)
       (# D: ^gbeta.DollarOp
       enter D[]
       <<SLOT do_DollarOp_body: DoPart>>
       #);
     do_QMarkOp: (* cons *)
       (# Q: ^gbeta.QMarkOp
       enter Q[]
       <<SLOT do_QMarkOp_body: DoPart>>
       #);
     do_BSlashOp: (* cons *)
       (# B: ^gbeta.BSlashOp
       enter B[]
       <<SLOT do_BSlashOp_body: DoPart>>
       #);
     do_TextConst: (* cons *)
       (# T: ^gbeta.TextConst
       enter T[]
       <<SLOT do_TextConst_body: DoPart>>
       #);
     do_IntegerConst: (* cons *)
       (# I: ^gbeta.IntegerConst
       enter I[]
       <<SLOT do_IntegerConst_body: DoPart>>
       #);
     do_NotExp: (* cons *)
       (# N: ^gbeta.NotExp
       enter N[]
       <<SLOT do_NotExp_body: DoPart>>
       #);
     do_NoneExp: (* cons *)
       (# N: ^gbeta.NoneExp
       enter N[]
       <<SLOT do_NoneExp_body: DoPart>>
       #);
     do_NameDcl: (* alternation *)
       (# N: ^gbeta.NameDcl
       enter N[]
       <<SLOT do_NameDcl_body: DoPart>>
       #);
     do_NameDclThis: (* cons *)
       (# N: ^gbeta.NameDclThis
       enter N[]
       <<SLOT do_NameDclThis_body: DoPart>>
       #);
     do_NameApl: (* cons *)
       (# N: ^gbeta.NameApl
       enter N[]
       <<SLOT do_NameApl_body: DoPart>>
       #);
     do_NameDclNormal: (* cons *)
       (# N: ^gbeta.NameDclNormal
       enter N[]
       <<SLOT do_NameDclNormal_body: DoPart>>
       #);

     do_nameDecl: (* lexem *)
       (# n: ^astinterface.nameDecl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_nameAppl: (* lexem *)
       (# n: ^astinterface.nameAppl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_const: (* lexem *)
       (# c: ^astinterface.const;
          getText: (# exit c.getText #);
          getValue: (# exit c.getValue #);
       enter c[] 
       do INNER;
       #);
     do_string: (* lexem *)
       (# s: ^astinterface.string;
          getText: (# exit s.getText #);
       enter s[] 
       do INNER;
       #);
     init: (* Initialization of astLevel and parser *)
       (# 
       <<SLOT gbeta_init_body: DoPart>>
       #);
  #);
