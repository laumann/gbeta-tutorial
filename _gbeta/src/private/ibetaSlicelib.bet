(* FILE "./private/ibetaSlicelib.bet"
 *
 * Copyright (C) 1997-2011 Erik Ernst
 *
 * This file is part of "gbeta" -- a generalized version of the
 * programming language BETA.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is destributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Among other things, the copyright notice and this notice must be
 * preserved on all copies.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, probably in a file named COPYING; if not,
 * write to the Free Software Foundation, Inc., 675 Mass Ave,
 * Cambridge, MA 02139, USA.
 *
 * To contact the author by email: eernst@cs.au.dk
 *
 * To contact the author by snail-mail:
 *    Erik Ernst
 *    Department of Computer Science
 *    University of Aarhus
 *    DK-8200 Aarhus N
 *    Denmark
 *)

ORIGIN '../ibetaSType';
INCLUDE 'basicinterplib';
INCLUDE 'ibetaCommonlib';
INCLUDE 'ibetaTwolib';
BODY 'ibetaSlicelibbody'

-- InterpreterBaseLib:attributes --

(*************************************************************
 *                                                           *
 *                        Tried Types                        *
 *                                                           *
 *************************************************************)

triedType: linkable
  (* Represents set of sptypes; used to ensure that we do not 
   * enter an infinite loop while traversing the universe 
   * for types known to be equal, so it is a set of "already 
   * tried types", which motivates the name *)
  (# knownType::triedType;
     selfType::triedType;
     init::(# enter sptype[] #);
     copyLink::(# do sptype[]->theCopy.sptype[] #);
     print:< printbase(# do (dest[],indentation,false)->sptype.print #);
     distinct: booleanValue(# enter sptype.distinctFromMe->value #);
     sptype: ^staticPatternType
  #);

addToTriedType:
  (* Extend 'tried' with 'sptype' and return the extended 
   * 'tried'; this works even for tried=NONE, in which
   * case the returned linked list is a fresh singleton *)
  (# tried: ^triedType;
     sptype: ^staticPatternType;
  enter (sptype[],tried[])
  <<SLOT StaticPatternTypeAddToTried:dopart>>
  exit tried[]
  #);

(*************************************************************
 *                                                           *
 *                     Static Transients                     *
 *                                                           *
 *************************************************************)

createSingletonTransient:
  (* Create and deliver a single static transient; 'type'
   * should be furtherbound to one of the concrete
   * static transients (bool/char/int/..)
   * whose 'init' does not expect arguments *)
  (# type:< staticTransient;
     stran: ^type
  <<SLOT CreateSingletonTransient:dopart>>
  exit stran[]
  #);

createEmptyTransient:
  (* Create and deliver an empty sublist transient *)
  (# sstran: ^staticSublistTransient
  <<SLOT CreateEmptyTransient:dopart>>
  exit sstran[]
  #);

(* ------------------------------------------------------------
 * Static coercion support (this is a quote from a mail in
 * betaexp, first an introduction here, and then the schemas
 * for the individual operation categories along with the
 * patterns for the categories):
 * ------------------------------------------------------------
 *
 *   Entries NOT shown are illegal.
 *   Entries marked with "*" are illegal.
 *
 *   Abbreviations:  iref    means   item reference
 *                   cref    means   component reference
 *                   sref    means   structure reference
 *
 *   NONE is both an iref and a cref. [EE: and an sref, probably?!]
 *
 *   In addition to the above types, there is also a primitive type.
 *   The result of any primitive operation %OP has this type.
 *   This type is compatible with most other types. I.e. it can e.g
 *   be assigned compared with/to int, bool, char.
 *   A complete specification is not yet available.
 *
 *   [EE: Assignment is handled with the operation "compatible"]
 *
 *   For assignment binary operators rows and columns show left
 *   and right operands respectively, and the elements show the
 *   result type.
 *
 *   Assignment: ->
 *
 *          | int  | char | real | bool | iref | cref | sref | str
 *     -------------------------------------------------------------
 *     int  | int  | char | real |  +   |  *   |  *   |  *   |  *
 *     -------------------------------------------------------------
 *     char | int  | char |  *   |  *   |  *   |  *   |  *   | str
 *     -------------------------------------------------------------
 *     real | int  |  *   | real |  *   |  *   |  *   |  *   |  *
 *     -------------------------------------------------------------
 *     bool |  *   |  *   |  *   | bool |  *   |  *   |  *   |  *
 *     -------------------------------------------------------------
 *     iref |  *   |  *   |  *   |  *   | iref |  *   |  *   |  *
 *     -------------------------------------------------------------
 *     cref |  *   |  *   |  *   |  *   |  *   | cref |  *   |  *
 *     -------------------------------------------------------------
 *     sref |  *   |  *   |  *   |  *   |  *   |  *   | sref |  *
 *     -------------------------------------------------------------
 *     str  | if1  | if1  |  *   |  *   |  *   |  *   |  *   | str
 *)

unOpStaticCoercionBase:
  (# input: ^staticTransient;
     usageAst: ^UsageAsts;
     output: ^staticTransient
  enter (input[],usageAst[])
  do INNER
  exit output[]
  #);

binOpStaticCoercionBase:
  (# right,left: ^staticTransient;
     usageAst: ^UsageAsts;
     output: ^staticTransient
  enter (left[],right[],usageAst[])
  do INNER
  exit output[]
  #);

binOpStaticCoercionDoesO2B: binOpStaticCoercionBase
  (# <<SLOT BinOpStaticCoercionDoesO2B:dopart>> #);

arithBinOpStaticCoercionBase: binOpStaticCoercionBase
  (# <<SLOT ArithBinOpStaticCoercionBase:dopart>> #);

arithBinOpStaticCoercionDoesO2B: binOpStaticCoercionDoesO2B
  (# <<SLOT ArithBinOpStaticCoercionDoesO2B:dopart>> #);

arithBinOpStaticCoercion: arithBinOpStaticCoercionDoesO2B
  (*   Binary operators:  -  *  div
   *
   *          | int  | char | real | str
   *     ---------------------------------
   *     int  | int  | int  | real | if1
   *     ---------------------------------
   *     char | int  | int  |  *   | if1
   *     ---------------------------------
   *     real | real |  *   | real |  *
   *     ---------------------------------
   *     str  | if1  | if1  |  *   | if1
   *)
  (# <<SLOT ArithBinOpStaticCoercion:dopart>> #);

plusBinOpStaticCoercion: arithBinOpStaticCoercionDoesO2B
  (*   Binary operators:  +
   *
   *          | int  | char | real | str
   *     ------------------------------------
   *     int  | int  | int  | real | if1
   *     ------------------------------------
   *     char | int  | int  |  *   | if1
   *     ------------------------------------
   *     real | real |  *   | real |  *
   *     ------------------------------------
   *     str  | if1  | if1  |  *   | if1/str
   *
   * [EE: non-singleton strings are given special treatment with '+':
   *  adding two strings, at least one of them non-literalchar, means
   *  concatenating them as strings; in all other cases the string(s)
   *  must be a literalchar and will be changed to int first]
   *)
  (# <<SLOT PlusBinOpStaticCoercion:dopart>> #);

modBinOpStaticCoercion: binOpStaticCoercionDoesO2B
  (*   Binary operator:  mod
   *
   *          | int  | char | str
   *     --------------------------
   *     int  | int  | int  | if1
   *     --------------------------
   *     char | int  | int  | if1
   *     --------------------------
   *     str  | if1  | if1  | if1
   *)
  (# <<SLOT ModBinOpStaticCoercion:dopart>> #);

rdivBinOpStaticCoercion: binOpStaticCoercionDoesO2B
  (*   Binary operator:  / (char will probably be eliminated here!)
   *
   *          | int  | char  | real | str
   *     ----------------------------------
   *     int  | real | real  | real | if1
   *     ----------------------------------
   *     char | real | real  |  *   | if1
   *     ----------------------------------
   *     real | real |  *    | real |  *
   *     ----------------------------------
   *     str  | if1  | if1   |  *   | if1
   *)
  (# <<SLOT RdivBinOpStaticCoercion:dopart>> #);

eqneqBinOpStaticCoercion: binOpStaticCoercionBase
  (*   Binary operators:  =  <>
   *
   *          | int  | char | real | bool | iref | cref | sref | str
   *     -------------------------------------------------------------
   *     int  | bool | bool | bool |  *   |  *   |  *   |  *   | if1
   *     -------------------------------------------------------------
   *     char | bool | bool | bool |  *   |  *   |  *   |  *   | if1
   *     -------------------------------------------------------------
   *     real | bool | bool | bool |  *   |  *   |  *   |  *   | if1
   *     -------------------------------------------------------------
   *     bool |  *   |  *   |  *   | bool |  *   |  *   |  *   |  *
   *     -------------------------------------------------------------
   *     iref |  *   |  *   |  *   |  *   | bool |  *   |  *   |  *
   *     -------------------------------------------------------------
   *     cref |  *   |  *   |  *   |  *   |  *   | bool |  *   |  *
   *     -------------------------------------------------------------
   *     sref |  *   |  *   |  *   |  *   |  *   |  *   | bool |  *
   *     -------------------------------------------------------------
   *     char | if1  | if1  | if1  |  *   |  *   |  *   |  *   | bool
   *)
  (# <<SLOT EqneqBinOpStaticCoercion:dopart>> #);

uneqBinOpStaticCoercion: binOpStaticCoercionDoesO2B
  (*   Binary operators:  <  <=  >  >=  [EE: added pref column&row]
   *
   *          | int  | char | real | bool | pref | str
   *     -----------------------------------------------
   *     int  | bool | bool | bool |  *   |  *   | if1
   *     -----------------------------------------------
   *     char | bool | bool | bool |  *   |  *   | if1       <-- !! char<string
   *     -----------------------------------------------            raises char
   *     real | bool | bool | bool |  *   |  *   | if1
   *     -----------------------------------------------
   *     bool |  *   |  *   |  *   | bool |  *   |  *
   *     -----------------------------------------------
   *     pref |  *   |  *   |  *   |  *   | pref |  *
   *     -----------------------------------------------
   *     str  | if1  | if1  | if1  |  *   |  *   | bool
   *)
  (# <<SLOT UneqBinOpStaticCoercion:dopart>> #);

andorBinOpStaticCoercion: binOpStaticCoercionDoesO2B
  (*   Binary operators:  and or [EE: and "xor"]
   *
   *          | bool
   *     ------------
   *     bool | bool
   *)
  (# <<SLOT AndorBinOpStaticCoercion:dopart>> #);

addUnOpStaticCoercion: unOpStaticCoercionBase
  (*   Unary operators:  +  -
   *
   *     int, char, real result type is the same as operand type
   *)
  (# <<SLOT AddUnOpStaticCoercion:dopart>> #);

notUnOpStaticCoercion: unOpStaticCoercionBase
  (*   Unary operator:  not
   *
   *     bool    result type is  bool
   *)
  (# <<SLOT NotUnOpStaticCoercion:dopart>> #);

ifExitStaticCoercion:
  (* Finally we have a new case, namely evaluation of an if statement
   * which is not present in BETA at all.  It may involve coercion
   * of one of the branches, and this method describes the resulting
   * transient value.  (The generation of instructions to actually
   * perform the coercion is done by ifExitCoerce, which means that
   * these two methods must be kept consistent if any of these
   * coercions are changed.)
   *
   * Note that if the coercion is concerned with pRef/oRef transients
   * and the coercion is not possible (due to incompatible kinds) then
   * 'onIncompatible' is invoked, which means that this situation must
   * be handled by the caller.  It is then possible to choose to insert
   * dynamic checks rather than just rejecting the program.  For other
   * failing cases (such as (then:string,else:real) etc), a static
   * error is raised unconditionally, just like in other StaticCoercion
   * methods.
   *
   *   "=" means coercion not needed
   *   "*" means coercion impossible
   *   "<type>" means coercion arrives here for both
   *
   *      | bool | char | int  | real | str  | str1 | oref | ptn  | none
   * --------------------------------------------------------------------
   * bool |  =   |  *   |  *   |  *   |  *   |  *   |  *   |  *   |  *
   * --------------------------------------------------------------------
   * char |  *   |  =   | int  |  *   | str  | char |  *   |  *   |  *
   * --------------------------------------------------------------------
   * int  |  *   | int  |  =   | real |  *   | int  |  *   |  *   |  *
   * --------------------------------------------------------------------
   * real |  *   |  *   | real |  =   |  *   |  *   |  *   |  *   |  *
   * --------------------------------------------------------------------
   * str  |  *   | str  |  *   |  *   |  =   | str  |  *   |  *   |  *
   * --------------------------------------------------------------------
   * str1 |  *   | char | int  |  *   | str  |  =   |  *   |  *   |  *
   * --------------------------------------------------------------------
   * oref |  *   |  *   |  *   |  *   |  *   |  *   |  =   |  *   | oref
   * --------------------------------------------------------------------
   * ptn  |  *   |  *   |  *   |  *   |  *   |  *   |  *   |  =   | ptn
   * --------------------------------------------------------------------
   * none |  *   |  *   |  *   |  *   |  *   |  *   | oref | ptn  |  =
   * --------------------------------------------------------------------
   *)
  (# onIncompatible:< object;
     fail: (# <<SLOT IfExitStaticCoercionFail:dopart>> #);
     context: ^staticContext;
     thenSTran,elseSTran: ^staticTransient;
     usageAst: ^UsageAsts;
     resultSTran: ^staticTransient
  enter (context[],thenSTran[],elseSTran[],usageAst[])
  <<SLOT ifExitStaticCoercion:dopart>>
  exit resultSTran[]
  #);

impossibleStaticUnCoercion:
  (* Tell user that the requested coercion is not available *)
  (# input: ^staticTransient;
     usageAst: ^UsageAsts;
     solution: ^text
  enter (input[],usageAst[],solution[])
  <<SLOT ImpossibleStaticUnCoercion:dopart>>
  #);

impossibleStaticBinCoercion:
  (* Tell user that the requested coercion is not available *)
  (# left,right: ^staticTransient;
     usageAst: ^UsageAsts
  enter (left[],right[],usageAst[])
  <<SLOT ImpossibleStaticBinCoercion:dopart>>
  #)

(*************************************************************
 *                                                           *
 *                       Static Slices                       *
 *                                                           *
 *************************************************************)

-- StaticSliceListLib:attributes --

print: printBase
  (# withEach: (# current: ^patternStaticSlice enter current[] do INNER #);
     before:< object;
     beforeEach:< withEach;
     afterEach:< withEach;
     after:< object;
     element_nl: @boolean               (* per-element 'nl' *)
  enter element_nl
  <<SLOT StaticSliceListPrint:dopart>>
  #);

printShort: printBase
  (# withEach: (# current: ^patternStaticSlice enter current[] do INNER #);
     before:< object;
     beforeEach:< withEach;
     afterEach:< withEach;
     after:< object;
     element_nl: @boolean               (* per-element 'nl' *)
  enter element_nl
  <<SLOT StaticSliceListPrintShort:dopart>>
  #);

observe: observeBase(# <<SLOT StaticSliceListObserve:dopart>> #)

-- RelatedTypeLib:attributes --

debugprint: debugprintBase(# <<SLOT RelatedTypeDebugPrint:dopart>> #);

-- StaticPatternTypeLib:attributes --

insert:
  (* Insert 'new' into this staticPatternType as the frontmost
   * link; 'new' is owned by this staticPatternType thereafter *)
  (# new: ^patternStaticSlice;
     usageAst: ^UsageAsts;
     propagationStsub: ^staticSubstance
  enter (new[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeInsert:dopart>>
  #);

newRelatedType:
  (* Add a freshly created related type entry to this
   * static pattern type, and let it be initialized in
   * INNER; abstract: use the specializations below *)
  (# T:< relatedType; newrt: ^T
  <<SLOT StaticPatternTypeNewRelatedType:dopart>>
  exit newrt[]
  #);

newRelatedVirtualType: newRelatedType(# T::relatedVirtualType do INNER #);
newRelatedObjectType: newRelatedType(# T::relatedObjectType do INNER #);
newRelatedWhenType: newRelatedType(# T::relatedWhenType do INNER #);

addRelatedTypes:
  (* add the provided list of related types to my list of related types;
   * remember to copy the provided list when giving it as argument to
   * this method if it is used by another type *)
  (# rtyp: ^relatedType
  enter rtyp[]
  <<SLOT StaticPatternTypeAddRelatedType:dopart>>
  #);

clearRelatedTypes:
  (* Delete all the related types of this static pattern type *)
  (# <<SLOT StaticPatternTypeClearRelatedTypes:dopart>> #);

copyRelatedTypes:
  (* Copy the related types of 'other' and add
   * the copies to this static pattern type *)
  (# other: ^staticPatternType
  enter other[]
  <<SLOT StaticPatternTypeCopyRelatedTypes:dopart>>
  #);

copyRelatedTypesAsMaybeless:
  (* Copy the related types of 'other' and add the copies to
   * this static pattern type, forcing each of the copies to
   * be marked 'maybeless' *)
  (# other: ^staticPatternType
  enter other[]
  <<SLOT StaticPatternTypeCopyRelatedTypesAML:dopart>>
  #);

makeRelatedMaybeless: (# <<SLOT StaticPatternTypeMkRML:dopart>> #);

mixin:
  (* Mixin-like inheritance:  In the given ('focus','context','world'),
   * enhance this static pattern type by using it as the type
   * of the prefix for this main part, and deliver the result; the operation
   * changes 'sptype', so beware of aliasing! *)
  (# focus: ^patternStaticSlice;        (* NONE for non-object contexts *)
     context: ^staticContext;           (* Never NONE *)
     world: ^staticContextDB;           (* Never NONE *)
     l2mpar: ^l2MainPart;               (* Never NONE *)
     usageAst: ^UsageAsts;              (* Used for diagnostics *)
     propagationStsub: ^staticSubstance (* ditto *)
  enter (focus[],context[],l2mpar[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeMixin:dopart>>
  #);

rawMerge:
  (* A "raw" purely slice-based merge operation; 'other' is unchanged
   * but this(staticPatternType) gets modified to hold the merge; note
   * that this method should _only_ be called from 'merge', because
   * it does not adjust related type info, etc. *)
  (# other: ^staticPatternType;
     l2dclast: ^l2AstNode;              (* Used for diagnostics *)
     usageAst: ^UsageAsts               (* For diagnostics, too! *)
  enter (other[],l2dclast[],usageAst[])
  <<SLOT StaticPatternTypeRawMerge:dopart>>
  #);

merge:
  (* Merge 'other' onto this staticPatterntype; 'other' gets copied
   * and is thus not affected by the operation *)
  (# OnDynMergeWarning:<
       (# usageAst: ^UsageAsts;
          ltype,rtype: ^staticType
       enter (usageAst[],ltype[],rtype[])
       do INNER 
       #);
     OnDynMergeDupMainPartWarning:<
       (# usageAst: ^UsageAsts;
          ltype,rtype: ^staticType
       enter (usageAst[],ltype[],rtype[])
       do INNER
       #);
     other: ^staticPatternType;
     l2dclast: ^l2AstNode;              (* Used for diagnostics *)
     usageAst: ^UsageAsts;              (* For diagnostics, too *)
     propagationStsub: ^staticSubstance; (* ditto! *)
     otherIsLessEqual,thisIsLessEqual: @boolean
  enter (other[],l2dclast[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeMerge:dopart>>
  #);

mergeMustSucceed:
  (# OnDynMergeWarning:<
       (# usageAst: ^UsageAsts;
          ltype,rtype: ^staticType
       enter (usageAst[],ltype[],rtype[])
       do INNER 
       #);
     OnDynMergeDupMainPartWarning:<
       (# usageAst: ^UsageAsts;
          ltype,rtype: ^staticType
       enter (usageAst[],ltype[],rtype[])
       do INNER
       #);
     stype: ^staticType;                (* Never NONE *)
     l2dclast: ^l2AstNode;              (* For diagnostics *)
     usageAst: ^UsageAsts;              (* For diagnostics, too *)
     propagationStsub: ^staticSubstance (* ditto! *)
  enter (stype[],l2dclast[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeMergeMustSucceed:dopart>>
  #);

weakMerge:
  (* Add all slices from 'other' that this staticPatternType 
   * does not already contain to the most specific end of me;
   * 'other' is not affected by this operation *)
  (# other: ^staticPatternType;
     usageAst: ^UsageAsts;
     propagationStsub: ^staticSubstance
  enter (other[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeWeakMerge:dopart>>
  #);

getCommonSuper:
  (* Remove all slices not in 'other', thus producing the 
   * least upper bound of 'other' and this static pattern
   * type, disregarding the ordering (i.e., as types) *)
  (# other: ^staticPatternType;
     usageAst: ^UsageAsts;
     propagationStsub: ^staticSubstance;
     sptype: ^staticPatternType
  enter (other[],usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeCommonSuper:dopart>>
  exit sptype[]
  #);

isRigid: booleanValue
  (* Return true iff this pattern is created such that 
   * every mixin depends on all the more general mixins,
   * typically by single inheritance only *)
  (# thisSize: @integer;
     sptype: ^staticPatternType
    <<SLOT StaticPatternTypeIsRigid:dopart>>
  #);

hasNoVisibleSlices: booleanValue
  (* Returns true iff this static pattern type contains
   * zero visible mixins, even if it is not statically
   * known.  NB: This is relevant for checking how to
   * merge etc, but it does _not_ imply that this pattern
   * type has type object (because maybeless may be true) *)
  (# <<SLOT StaticPatternTypeHasNoVisibleSlices:dopart>> #);

hasInvisibleSlices: booleanValue
  (* Returns true iff this static pattern type contains
   * invisible mixins; it is used in the creation of a
   * description of multiple patterns (typically, for the
   * type delivered by a value-if), which should not contain
   * any invisible slices because they are (generally) not
   * shared among the multiple patterns (for value-if: among
   * the two branches); we may then "purify" the pattern 
   * type such that it does not describe any invisible slices
   * at all.  Note that this should not make any difference
   * for typing considerations, because invisible slices
   * should have no effect on typing, but it still looks weird
   * that "if b then p1# else p2#" gets a type that mentions
   * the invisible slices of (say) p1#, even though the value
   * at runtime may just as well be p2# *)
  (# <<SLOT StaticPatternTypeHasInvisibleSlices:dopart>> #);

getVisiblePart:
  (* Create and deliver a copy of this static pattern type which
   * does not include any invisible slices; this is a kind of
   * "purification" which provides a description of the type of
   * this static pattern type; it always creates a fresh copy
   * in cases where any invisible slices exist.  It is assumed
   * that hasInvisibleSlices is used to check that this operation
   * is needed, so this operation will not attempt to detect that
   * the operation is unneded and reduce the work done for
   * that case *)
  (# sptype: ^staticPatternType
  <<SLOT StaticPatternTypeGetVisiblePart:dopart>>
  exit sptype[]
  #);

implEqual: booleanValue
  (* An equality test which tests whether this and other are the
   * same pattern, including invisible mixins and mixin ordering *)
  (# otherSPType: ^staticPatternType;
     otherSlice: ^patternStaticSlice
  enter otherSPType[]
  <<SLOT StaticPatternTypeImplEqual:dopart>>
  #);

rawEqual: booleanValue
  (* A "raw", purely slice-based structural equality test for pattern types *)
  (# otherSPType: ^staticPatternType;
     otherSlice,otherStopSlice: ^patternStaticSlice
  enter otherSPType[]
  <<SLOT StaticPatternTypeRawEqual:dopart>>
  #);

rawLessEqual: booleanValue
  (* A "raw", purely slice-based structural comparison of pattern types *)
  (# otherSPType: ^staticPatternType;
     otherSlice,otherStopSlice: ^patternStaticSlice
  enter otherSPType[]
  <<SLOT StaticPatternTypeRawLessEqual:dopart>>
  #);

lessEqualIgnoreConstraints: booleanValue
  (# (* 'perhaps' is invoked if absolute info says "yes" but my growth may
      * destroy the "<=" relation, e.g. "I am virtual but other is not" *)
     perhaps:< object;
     other: ^staticPatternType;
     usageAst: ^UsageAsts;
     otherSlice: ^staticSlice;
     do_perhaps: @boolean (* private *)
  enter (other[],usageAst[])
  <<SLOT StaticPatternTypeLessEqualIgnoreConstraints:dopart>>
  #);

isConstraintFree: booleanValue
  (# <<SLOT StaticPatternTypeIsConstraintFree:dopart>> #);

clearConstraints:
  (# <<SLOT StaticPatternTypeClearConstraints:dopart>> #);

satisfiesConstraint: booleanValue
  (* Check whether an instance of this staticPatternType 
   * will provably be an object for which the constraint
   * 'cst' is satisfied *)
  (# <<SLOT SatisfiesConstraintlib:attributes>>;
     usageAst: ^UsageAsts;
     tried: ^triedType;
     cst: ^staticCst;
  enter (cst[],tried[],usageAst[])
  <<SLOT StaticPatternTypeSatisfiesConstraint:dopart>>
  #);

satisfiesConstraintByConstraints: booleanValue
  (* Check whether an instance of this staticPatternType 
   * will provably be an object for which the constraint
   * 'cst' is satisfied, based only on my constaints *)
  (# cst: ^staticCst;
     tried: ^triedType;
     usageAst: ^UsageAsts
  enter (cst[],tried[],usageAst[])
  <<SLOT StaticPatternTypeSatisfiesCstrByCstr:dopart>>
  #);

satisfiesConstraintByRelatedTypes: booleanValue
  (# cst: ^staticCst;
     tried: ^triedType;
     usageAst: ^UsageAsts
  enter (cst[],tried[],usageAst[])
  <<SLOT StaticPatternTypeSatisfiesCstrByRT:dopart>>
  #);

satisfiesObjCstr: booleanValue
  (* Check whether an instance of this staticPatternType 
   * will provably be an object for which the constraint
   * 'ocst' is satisfied *)
  (# ocst: ^staticObjCst;
     tried: ^triedType
  enter (ocst[],tried[])
  <<SLOT StaticPatternTypeSatisfiesObjCstr:dopart>>
  #);

check:
  (* Verify that this static pattern type is well-formed; if not,
   * and the violation is the presence of more than one composite
   * slice referring to the same main part, 'duplicateError'
   * is invoked; if the violation is that the resulting pattern
   * would contain a virtual whose virtual-chain (of declarations)
   * is not well-formed, i.e. it is not (:<)(::)*, then
   * 'virtualError' is invoked *)
  (# duplicateError:< exception
       (# err:
            (* call as ('my message',usageAst[],l2mpar[])->err from the
             * dopart of your duplicateError furtherbinding; it will
             * then set up the texts for a staticError and raise it *)
            (# msg: ^text;
               usageAst: ^UsageAsts;
               l2mpar: ^l2MainPart
            enter (msg[],usageAst[],l2mpar[])
            <<SLOT StaticPatternTypeCheckErr:dopart>>
            #);
          usageAst: ^UsageAsts;
          l2mpar: ^l2MainPart;
          org1,org2: ^runtimepath
       enter (usageAst[],l2mpar[],org1[],org2[])
       do INNER
       #);
     virtualError:< exception;
     usageAst: ^UsageAsts;
     propagationStsub: ^staticSubstance
  enter (usageAst[],propagationStsub[])
  <<SLOT StaticPatternTypeCheck:dopart>>
  #);

distinctFromMe: booleanValue
  (# other: ^staticPatternType;
  enter other[]
  <<SLOT StaticPatternTypeDistinct:dopart>>
  #);

alreadyTried: booleanValue
  (* make sure that this static pattern type has not already been tried *)
  (# tried: ^triedType
  enter tried[]
  <<SLOT StaticPatternTypeAlreadyTried:dopart>>
  #);

lessEqualWithTried: booleanValue
  (* This is the basic implementation of less equal for a
   * static pattern type. It extends the ordinary lessEqual
   * with an extra argument, tried, that contains
   * the static pattern types we have tried to use to
   * "play the role as me" based on related types info;
   * this is required in order to ensure that we do not
   * enter an infinite loop while traversing equality
   * constraints all over the static universe *)
  (# other: ^staticType;
     tried: ^triedType;
     other_tried: ^triedType;
     usageAst: ^UsageAsts;
     notsure:< object
  enter (other[],tried[],other_tried[],usageAst[])
  <<SLOT StaticPatternTypeLessEqualWithTried:dopart>>
  #);

substanceLessEqualWithTried: booleanValue
  (* This is the basic implementation of substance 
   * less equal for a static pattern type. It extends 
   * the ordinary substanceLessEqual method with an
   * extra argument, tried, and works similarly to
   * lessEqualWithTried *)
  (# other: ^staticSubstance;
     tried: ^triedType;
     other_tried: ^triedType;
     usageAst: ^UsageAsts;
     notsure:< object
  enter (other[],tried[],other_tried[],usageAst[])
  <<SLOT StaticPatternTypeSubstanceLessEqualWithTried:dopart>>
  #);

badKind: (# <<SLOT StaticPatternTypeBadKind:dopart>> #);

getStaticTransientOut:
  (* Used only from staticOCP.getStaticTransientOut, so the 'context' 
   * will always be a staticOCP whose 'sptype' is exactly this static 
   * pattern type *)
  (# depth: @integer;                   (* Used to detect loops *)
     context: ^staticContext;           (* Never NONE *)
     usageAst: ^UsageAsts;              (* Used for diagnostics *)
     stran: ^staticTransient            (* Never NONE *)
  enter (depth,context[],usageAst[])
  <<SLOT StaticPatternTypeGetTranOut:dopart>>
  exit stran[]
  #);

getStaticTransientIn:
  (* Used only from staticOCP.getStaticTransientIn, so the 'context' 
   * will always be a staticOCP whose 'sptype' is exactly this static 
   * pattern type *)
  (# depth: @integer;                   (* Used to detect loops *)
     context: ^staticContext;           (* Never NONE *)
     usageAst: ^UsageAsts;              (* Used for diagnostics *)
     stran: ^staticTransient            (* Never NONE *)
  enter (depth,context[],usageAst[])
  <<SLOT StaticPatternTypeGetTranIn:dopart>>
  exit stran[]
  #);

tmpInstantiate:
  (* Create a staticOCP which describes an instance of
   * this static pattern type located on the tmp stack
   * at the given 'framepos' index; the 'generatingAst'
   * is used to uniquely identify the temporary such that
   * temps. discovered during analysis (not codegen) which
   * do not have a precisely known tmp.stack location can
   * still be recognized as "the same" or "(possibly) not
   * the same" *)
  (# focus: ^patternStaticSlice;        (* NONE for non-object contexts *)
     context: ^staticContext;           (* Never NONE *)
     usageAst: ^UsageAsts;              (* Used for diagnostics *)
     astRole: @integer;                 (* Refine meaning of generatingAst *)
     framepos: @integer;                (* Position in tmp stack *)
     tmpstocp: ^staticOCP
  enter (focus[],context[],usageAst[],astRole,framePos)
  <<SLOT StaticPatternTypeTmpInstantiate:dopart>>
  exit tmpstocp[]
  #);

allTmpKnown: booleanValue
  (* Return true if every origin path in this static pattern either
   * refers to a non-tmp-at-unknown-pos-entity, or the origin path
   * refers to a tmp-at-unknown-pos-entity, but it also has an
   * effectiveOriginPath to compensate *)
  (# <<SLOT StaticPatternTypeAllTmpKnown:dopart>> #);

chkAllTmpKnown:
  (* DEBUG: to make sure that we never return a 'gensptype' or
   * similar description from a code generating method that
   * contains descriptions of objects at unknown positions
   * on the temporary stack (be it the object itself or its
   * enclosing entities) *)
  (# <<SLOT StaticPatternTypeChkAllTmpKnown:dopart>> #);

ast2slice:
  (# l2ast: ^l2AstNode;                 (* Never NONE *)
     pSlice: ^patternStaticSlice        (* NONE means "not found" *)
  enter l2ast[]
  <<SLOT StaticPatternTypeAst2Slice:dopart>>
  exit pSlice[]
  #);

makeNotKnownStatically:
  (* Change this static pattern type such that 'knownStatically'
   * will not return true.  Note that if you want to change the
   * description of an entity such that it is no longer known
   * to be constrained from below (e.g., during coercion from
   * the type of a pattern used as a qualification for a dynamic
   * item and the type of the object obtained by evaluation of
   * that item) then we must also adjust the Related..Type info,
   * using makeMaybeless *)
  (# <<SLOT StaticPatternTypeMakeNKS:dopart>> #);
  
makeImplNotKnownStatically:
  (* Change this static pattern type such that 'implKnownStatically'
   * will not return true.  Note that if you want to change the
   * description of an entity such that it is no longer known
   * to be constrained from below (e.g., during coercion from
   * the type of a pattern used as a qualification for a dynamic
   * item and the type of the object obtained by evaluation of
   * that item) then we must also adjust the Related..Type info,
   * using makeMaybeless *)
  (# <<SLOT StaticPatternTypeMakeINKS:dopart>> #);
  
makeMaybeless:
  (* Change this static pattern type such that 'knownStatically'
   * will not return true and all exact Related...Type
   * information is changed to 'maybeless'.  Another description
   * is that this is used when knowledge about a pattern is
   * converted into knowledge about an entity (e.g., object)
   * whose pattern is constrained by the former value of this
   * static pattern type as an upper bound *)
  (# <<SLOT StaticPatternTypeMakeML:dopart>> #);

makeConstraintsMaybeless:
  (* Change this static pattern type such that every virtual
   * pattern EqualCstOp constraint is changed to a SubCstOp, and
   * every SuperCstOp is removed (no interesting information is
   * preserved); SubCstOp constraints are left unchanged.  This
   * transforms the static pattern type from a description of
   * an object obtained from a type, possibly previously coerced
   * into a pattern (there must have been a type which introduced
   * the virtual constraints) to a description of an object/pattern
   * which is a subpattern of a pattern that satisfied those
   * constraints.   The typical example is as follows:
   * 
   *   { A: %{ T:< object; me: %(|: ^this(A)) }; aa: A[A] #
   *     aa.me.T | .. // aa.me is a "subpattern of A[A]", so T<=A, not T=A
   *   }
   * 
   * NB: it is not known locally at this(A) that a type (A[A]) will be 
   * involved, so we cannot outlaw the "offending declaration" (me/return)
   *)
  (# <<SLOT StaticPatternTypeMakeCML:dopart>> #);

makeKnownStatically:
  (* Change this static pattern type such that 'knownStatically'
   * will return true *)
  (# <<SLOT StaticPatternTypeMakeKS:dopart>> #);

makeImplKnownStatically:
  (* Change this static pattern type such that 'implKnownStatically'
   * will return true *)
  (# <<SLOT StaticPatternTypeMakeKSI:dopart>> #);

gbcPrint: printBase
  (* Print this pattern in a format which denotes a static 
   * pattern in a gbc output file, i.e., as a Pattern(..) 
   * block containing a list of mixin specifications (i.e., 
   * pattern slices); for each composite slice, call INNER with
   * current_cSlice bound to that slice, in order to enable
   * the caller to print information about nested features
   * such as statically known virtual patterns *)
  (# mark: @integer;
     current_cSlice: ^compositeStaticSlice
  enter mark
  <<SLOT StaticPatternTypeGbcPrint:dopart>> 
  #);

gbcMark: textValue
  (# l2ndcl: ^l2NameDcl
  enter l2ndcl[]
  <<SLOT StaticPatternTypeGbcMark:dopart>>
  #);

gbcPrintDecl: gbcPrint
  (# l2ndcl: ^l2NameDcl
  enter l2ndcl[]
  <<SLOT StaticPatternTypeGbcPrintDecl:dopart>>
  #);

gbcPrintInsertedItem: gbcPrint
  (# l2oden: ^l2ObjectDenotation
  enter l2oden[]
  <<SLOT StaticPatternTypeGbcPrintInsertedItem:dopart>>
  #);

createPattern:
  (# thrd: ^thread;
     unwind: ##stackUnwinder;
     dContext: ^substanceSlice;
     l1pat: ^l1PatternEntity
  enter (thrd[],unwind##,dContext[])
  <<SLOT StaticPatternTypeCreatePattern:dopart>>
  exit l1pat[]
  #);

createType:
  (# thrd: ^thread;
     unwind: ##stackUnwinder;
     dContext: ^substanceSlice;
     l1typ: ^l1TypeEntity
  enter (thrd[],unwind##,dContext[])
  <<SLOT StaticPatternTypeCreateType:dopart>>
  exit l1typ[]
  #);

createObject:
  (# thrd: ^thread;
     unwind: ##stackUnwinder;
     dContext: ^substanceSlice;
     l1pat: ^l1PatternEntity;
     l1obj: ^l1ObjectEntity;
     oofo: ^stackableObject
  enter (thrd[],unwind##,dContext[])
  <<SLOT StaticPatternTypeCreateObject:dopart>>
  exit l1obj[]
  #);

isComponent: booleanValue
  (* Returns true iff this static pattern type is known to contain
   * a component slice *)
  (# <<SLOT StaticPatternTypeIsComponent:dopart>> #);

isPredefined: booleanValue
  (* Determine whether this is one of the predefined patterns in gbeta;
   * note that arrays are not included as predefined in this context *)
  (# <<SLOT StaticPatternTypeIsPredefined:dopart>> #);

predefinedCases:
  (* This static pattern type must be one of the predefined patterns
   * in gbeta; then, invoke the corresponding callback below; note
   * that this is _only_correct_ if it is established by 'isPredefined'
   * that this pattern type is predefined (otherwise it could be a 
   * pattern with 2 or more mixins including a predefined one) *)
  (# onObject:< object;
     onBoolean:< object;
     onChar:< object;
     onInteger:< object;
     onReal:< object;
     onString:< object;
     onComponent:< object;
     onSemaphore:< object
  <<SLOT StaticPatternTypePredefinedCases:dopart>>
  #);

generateGetPredefinedPattern:
  (* This must be one of the predefined patterns in gbeta; then, add
   * one bytecode to program to push that pattern on the ptn.stack *)
  (# program: ^betaByteCodeList
  enter program[]
  <<SLOT StaticPatternTypeGenerateGetPredefinedPattern:dopart>>
  #);

generateGetPredefinedObject:
  (* This must be one of the predefined patterns in gbeta; then, add
   * one bytecode to program to push an instance on the objref. stack *)
  (# program: ^betaByteCodeList
  enter program[]
  <<SLOT StaticPatternTypeGenerateGetPredefinedObject:dopart>>
  #);

generateGetPredefinedTmp:
  (* This must be one of the predefined patterns in gbeta; then, add
   * one bytecode to program to push an instance on the tmp. stack *)
  (# framePos: @integer;
     program: ^betaByteCodeList
  enter (framePos,program[])
  <<SLOT StaticPatternTypeGenerateGetPredefinedTmp:dopart>>
  #)

-- StaticPrimitiveEntityTypeLib:attributes --

transferBasicState:
  (# other: ^StaticPrimitiveEntityType
  enter other[]
  <<SLOT StaticPrimitiveEntityTypeTransferBasicState:dopart>>
  #)

-- StaticOCPLib:attributes --

printShort: printBase(# <<SLOT StaticOCPPrintShort:dopart>> #);

sameOriginScan:
  (* Scan-like operation: INNER is executed for each accepted
   * slice with 'current' referring to it.  Works like this:
   * Walk down the static slices of this static OCP to
   * visit all those whose origin is statically known to be
   * the same object (substance) as found with 'originPath' *)
  (# originPath: ^runtimePath;		(* Never NONE *)
     current: ^staticSlice 		(* Never NONE *)
  enter originPath[]
  <<SLOT StaticOCPSameOriginScan:dopart>>
  #);

checkFinalObject:
  (* Check that the final object binding 'l2fsit' in 'focus' 
   * is not violated in context of this 'staticOCP' *)
  (# focus: ^patternStaticSlice;
     usageAst: ^UsageAsts;
     l2fsit: ^l2FinalStaticItem
  enter (focus[],usageAst[],l2fsit[])
  <<SLOT StaticOCPCheckFinalObject:dopart>>
  #);

checkFinals:
  (* Check that no final binding in this 'staticOCP' is violated *)
  (# usageAst: ^UsageAsts;
  enter usageAst[]
  <<SLOT StaticOCPCheckFinals:dopart>>
  #);

getFinalStaticItem:
  (* Given a virtual static item 'l2vsit' this static OCP is scanned in
   * order to find a corresponding final binding 'l2fsit'; if no such
   * final binding is found, NONE is returned *)
  (# l2vsit: ^l2VirtualStaticItem;      (* Never NONE *)
     l2fsit: ^l2FinalStaticItem;        (* NONE means "not found" *)
  enter l2vsit[]
  <<SLOT StaticOCPGetFinalStaticItem:dopart>>
  exit l2fsit[]
  #);

generateGetPattern:
  (* Generate code to ensure that the pattern associated with
   * this staticOCP ends up on the 'patterns' stack and to
   * check that it is not NONE unless 'noneAllowed' *)
  (# program: ^betaByteCodeList;
     cInfo: ^compileInfo;
     noneAllowed: @boolean;
     usageAst: ^UsageAsts;
     gensptype: ^staticPatternType
  enter (program[],cInfo[],noneAllowed,usageAst[])
  <<SLOT StaticOCPGenerateGetPattern:dopart>>
  exit gensptype[]
  #);

generateGetObject:
  (* Generate code to ensure that an object associated with
   * this staticOCP ends up on the 'objRefs' stack and to
   * check that it is not NONE; this may instantiate a
   * pattern in order to obtain an object *)
  (# program: ^betaByteCodeList;
     cInfo: ^compileInfo;
     noneAllowed: @boolean;
     usageAst: ^UsageAsts;
     genstocp: ^staticOCP
  enter (program[],cInfo[],noneAllowed,usageAst[])
  <<SLOT StaticOCPGenerateGetObject:dopart>>
  exit genstocp[]
  #);

generateGetTmpObject:
  (* Generate code to ensure that an object associated with
   * this staticOCP ends up on the 'tmpObjs' stack and to
   * check that it is not NONE; this may instantiate a
   * pattern in order to obtain an object *)
  (# program: ^betaByteCodeList;
     cInfo: ^compileInfo;
     usageAst: ^UsageAsts;
     genstocp: ^staticOCP;
     framePos: @integer
  enter (program[],cInfo[],usageAst[])
  <<SLOT StaticOCPGenerateGetTmpObject:dopart>>
  exit genstocp[]
  #);

createTmpVersion:
  (* The "normal" usage context for this method is
   * byte code generation; an object will be placed on
   * the 'tmpObjs' stack at run-time, possibly created
   * from a pattern, and the original entity (whether
   * an object(ref) or a pattern(ref)) is described by
   * this staticOCP; the returned 'tmpbased_stocp' will
   * then describe the object on the 'tmpObjs' stack;
   * We can use it during analysis, too, but in this
   * case the 'framePos' is 'unknownStackPos' since
   * we so not know the exact tmp.object stack layout,
   * and this means that the 'generatingAst' becomes
   * the tie breaker: two tmp. objects are considered the
   * same if they have unknown stack pos and same
   * generating AST; conclusion: use a consistent choice
   * of 'generatingAst' args!  Inconsistency does not affect
   * soundness, but it does cause the rejection of some
   * programs that are actually typesafe, since we "cannot
   * discover that certain temps. are the same object" *)
  (# usageAst: ^UsageAsts;
     astRole: @integer;
     framePos: @integer;
     path: ^runtimePath;
     tmpbased_sptype: ^staticPatternType;
     tmpbased_stocp: ^staticOCP
  enter (usageAst[],astRole,framePos)
  <<SLOT StaticOCPCreateTmpVersion:dopart>>
  exit tmpbased_stocp[]
  #);

satisfiesConstraint: booleanValue
  (* Check whether the object described by this staticOCP
   * will provably satisfy the constraint 'cst' *)
  (# cst: ^staticCst;
     tried: ^triedType;
     usageAst: ^UsageAsts
  enter (cst[],tried[],usageAst[])
  <<SLOT StaticOCPSatisfiesConstraint:dopart>>
  #);

satisfiesObjCstr: booleanValue
  (* Check whether the object described by this staticOCP
   * will provably satisfy the constraint 'ocst' *)
  (# ocst: ^staticObjCst;
     tried: ^triedType
  enter (ocst[],tried[])
  <<SLOT StaticOCPSatisfiesObjCstr:dopart>>
  #);

coerce:
  (# toKind: @integer;                  (* One of ".*TypeKind" *)
     usageAst: ^UsageAsts;              (* Used for diagnostics *)
     coerced_stocp: ^staticOCP          (* Never NONE *)
  enter (toKind,usageAst[])
  <<SLOT StaticOCPCoerce:dopart>>
  exit coerced_stocp[]
  #);

getCommonSuper:
  (* Create and return a new staticOCP that describes a
   * common supertype of 'other' and this static OCP.
   * Note that pathTo is made impossible, because there
   * is no way we could create a pathTo which targets
   * two distinct objects *)
  (# other: ^staticOCP;
     usageAst: ^usageAsts;
     context: ^staticContext;
     stocp: ^staticOCP
  enter (other[],usageAst[],context[])
  <<SLOT StaticOCPGetCommonSuper:dopart>>
  exit stocp[]
  #)

(*************************************************************
 *                                                           *
 *                     Static Transients                     *
 *                                                           *
 *************************************************************)

-- StaticTransientLib:attributes --

observe: observeBase(# <<SLOT StaticTransientObserve:dopart>> #)

-- StaticTransientListLib:attributes --

print: printBase
  (# withEach: (# current: ^staticTransient enter current[] do INNER #);
     before:< object;
     beforeEach:< withEach;
     afterEach:< withEach;
     after:< object;
     element_nl: @boolean               (* per-element 'nl' *)
  enter element_nl
  <<SLOT StaticTransientListPrint:dopart>>
  #);

printShort: printBase
  (# withEach: (# current: ^staticTransient enter current[] do INNER #);
     before:< object;
     beforeEach:< withEach;
     afterEach:< withEach;
     after:< object;
     element_nl: @boolean               (* per-element 'nl' *)
  enter element_nl
  <<SLOT StaticTransientListPrintShort:dopart>>
  #);

observe: observeBase(# <<SLOT StaticTransientListObserve:dopart>> #);

normalize:
  (* Bring this static transient list on a normal form;
   * if all static transient lists are on normal form,
   * comparisons can simply be carried out element by
   * element in the lists *)
  (# <<SLOT StaticTransientListNormalize:dopart>> #);

correlate: booleanValue
  (* Scan-like operation that runs through the two lists
   * in lockstep; for each pair of static transients
   * the virtual 'foreach' is executed; the operation
   * fails (terminates and returns false) if ever 'foreach'
   * returns false on a given pair, or if the lengths
   * of the two lists differ; otherwise 'true' is returned *)
  (# foreach:< booleanValue
       (# otherCurrent,current: ^staticTransient
       enter (otherCurrent[],current[])
       do INNER
       #);
     other: ^staticTransientList
  enter other[]
  <<SLOT StaticTransientListCorrelate:dopart>>
  #);

equal: correlate
  (* Determines whether 'other' is equal to this list;
   * assumes that both lists are on normal form *)
  (# forEach::(# do otherCurrent[]->current.equal->value #)#);

compatible: correlate
  (* Determines whether there are coercions such
   * that 'other' can be made equal to this list;
   * also assumes that the lists are on normal form *)
  (# forEach::
       (# 
       do (otherCurrent[],focus[],context[],usageAst[])
            ->current.compatible
            ->value 
       #);
     focus: ^staticSlice;               (* NONE for non-object contexts *)
     context: ^staticContext;           (* Never NONE *)
     usageAst: ^UsageAsts               (* Used for diagnostics *)
  enter (focus[],context[],usageAst[])
  #)

-- StaticSublistTransientLib:attributes --

add:
  (* Accept the static transient 'stran' for incorporation
   * into this static sublist transient; if 'stran' is
   * another sublist transient, its contents are (destructively)
   * transferred and appended to the contents of this sublist
   * transient, and if 'stran' is any other kind of transient
   * it is appended to the contents of this sublist transient;
   * this is used for composition of enter/exit lists from
   * the specialization levels of a static type *)
  (# stran: ^staticTransient
  enter stran[]
  <<SLOT StaticSublistTransientAdd:dopart>>
  #)

-- StaticOQuaTransientLib:attributes --

orefCompatible: booleanValue
  (* Check whether this oqua transient will be able to accept the
   * given oref transient in a reference assignment operation;
   * since the structural aspect of the values are trivially compatible
   * this is entirely a static qualification check; it returns true
   * if the reference assignment is always safe and false if it is
   * possibly unsafe (corresponding to a "quaWarning" given during check);
   * the four callbacks "on..." are invoked when the ref-ass. is unsafe
   * in one of four ways:
   *
   * 'onBoundUnsafe' indicates that only an upper bound is known where an
   * exactly known pattern would be required for safety (this is, e.g.,
   * the case when we are assigning from a constant type to a virtual
   * type which is OK locally but may of course grow).
   *
   * 'onDownUnsafe' is invoked when the ref-ass. includes a
   * down-cast (this is the classical qua-check situation in Beta)
   *
   * 'onUpUnsafe' is invoked when the ref-ass. includes an up-cast (this
   * is of course only a problem with an exact reference)
   *
   * 'onCrossUnsafe' is invoked when the involved pattern and qualification
   * are simply unrelated, as far as it is known statically (this is not
   * likely to succeed at run-time, but in some pathological cases it may)
   *)
  (# onBoundUnsafe:< object;
     onDownUnsafe:< object;
     onUpUnsafe:< object;
     onCrossUnsafe:< object;
     other: ^staticORefTransient;
     usageAst: ^UsageAsts
  enter (other[],usageAst[])
  <<SLOT StaticOQuaTransientORefCompatible:dopart>>
  #)

-- StaticPQuaTransientLib:attributes --

prefCompatible: booleanValue
  (* Check whether this pqua transient will be able to accept the
   * given pref transient in a variable pattern assignment operation;
   * since the structural aspect of the values are trivially compatible
   * this is entirely a static qualification check; it returns true
   * if the variable pattern assignment is always safe and false if it is
   * possibly unsafe (corresponding to a "quaWarning" given during check);
   * the three callbacks "on..." are invoked when the ref-ass. is unsafe
   * in one of three ways:
   *
   * 'onBoundUnsafe' indicates that only an upper bound is known where
   * an exactly known pattern would be required for safety (this is, e.g., the
   * case when we are assigning from a constant type to a virtual type
   * which is OK locally but may of course grow).
   *
   * 'onDownUnsafe' is invoked when the var-ptn-ass. includes a
   * down-cast (this is the classical qua-check situation in Beta)
   *
   * 'onCrossUnsafe' is invoked when the involved pattern and qualification
   * are simply unrelated, as far as it is known statically (this is not
   * likely to succeed at run-time, but in some pathological cases it may)
   *)
  (# onBoundUnsafe:< object;
     onDownUnsafe:< object;
     onUpUnsafe:< object;
     onCrossUnsafe:< object;
     other: ^staticPRefTransient;
     focus: ^patternStaticSlice;
     context: ^staticContext;
     usageAst: ^UsageAsts
  enter (other[],focus[],context[],usageAst[])
  <<SLOT StaticPQuaTransientPRefCompatible:dopart>>
  #)

(************************************************************
 *                                                          *
 *                   BETA Virtual Machine                   *
 *                                                          *
 ************************************************************)

-- BetaVirtualMachineLib:attributes --

print: printBase(# <<SLOT BetaVirtualMachinePrint:dopart>> #);
observe: observeBase(# <<SLOT BetaVirtualMachineObserve:dopart>> #);

(*************************************************************
 *                                                           *
 *                         Execution                         *
 *                                                           *
 *************************************************************)

-- ComponentObjectSliceLib:attributes --

stackPopObject:
  (* Pop the stack until the first object and check that this
   * object is 'l1obj'; if not, raise an internal error! *)
  (# l1obj: ^l1ObjectEntity;
     thrd: ^thread
  enter (l1obj[],thrd[])
  <<SLOT ComponentObjectSlicePopObject:dopart>>
  #);

forkingExecute:
  (# thrd: ^thread;                     (* Current thread of execution *)
     unwind: ##stackUnwinder;           (* Never NONE *)
     new_impl_thread: ^|system          (* The new impl. thread created *)
  enter (thrd[],unwind##)
  <<SLOT ComponentObjectSliceForkingExecute:dopart>>
  exit new_impl_thread[]
  #)

-- ArrayObjectSliceLib:attributes --

put:
  (* put entity 'val' at index 'inx' of this array object
   * slice; note that gbeta arrays are zero-based whereas
   * the underlying BETA repetition is one-based *)
  (# thrd: ^thread;                (* Current thread of execution *)
     unwind: ##stackUnwinder;      (* Never NONE *)
     inx: @integer;                (* Where to 'put' the 'val' *)
     val: ^entityType              (* Never NONE *)
  enter (thrd[],unwind##,inx,val[])
  <<SLOT ArrayObjectSlicePut:dopart>>
  #);

get:
  (* return the entity at index 'inx' of this array object
   * slice; note that gbeta arrays are zero-based whereas
   * the underlying BETA repetition is one-based  *)
  (# thrd: ^thread;                (* Current thread of execution *)
     unwind: ##stackUnwinder;      (* Never NONE *)
     inx: @integer;                (* Where to 'get' the 'val' from *)
     val: ^entityType              (* Never NONE *)
  enter (thrd[],unwind##,inx)
  <<SLOT ArrayObjectSliceGet:dopart>>
  exit val[]
  #);

adjustLength:
  (# thrd: ^thread;
     unwind: ## stackUnwinder;
     count,oldrange: @integer
  enter (thrd[],unwind##,count)
  <<SLOT ArrayObjectSliceAdjustLength:dopart>>
  #)

-- ArrayOrObjectSliceLib:attributes --

conforms: booleanValue
  (* Check that the given l1obj satisfies the type requirements
   * for being the (future) value of an entry in this array of
   * object references; note that it will cause a runtime error
   * to call this on an exact object ref entity whose qualification
   * includes constraints, but it would be a bug in the 'check'
   * methods if such a situation arises so we just let it fail *)
  (# l1obj: ^l1ObjectEntity
  enter l1obj[]
  <<SLOT ArrayOrObjectSliceConforms:dopart>>
  #)

-- ArrayPrObjectSliceLib:attributes --

conforms: booleanValue
  (* Check that the given l1pat satisfies the type requirements
   * for being the pattern of the (future) value of this pattern
   * ref entity; note that it will cause a runtime error to call
   * this on an exact object ref entity whose qualification includes
   * constraints, but it would be a bug in the 'check' methods
   * if such a situation arises so we just let it fail
   *)
  (# l1pat: ^l1PatternEntity
  enter l1pat[]
  <<SLOT ArrayPrObjectSliceConforms:dopart>>
  #)

-- CompositeObjectSliceLib:attributes --

attrsDefine:
  (# l2ndcl: ^l2NameDcl;
     l1ent: ^l1Entity;
  enter (l2ndcl[],l1ent[])
  <<SLOT CompositeObjectSliceAttrsDefine:dopart>>
  #);

attrsLookup:
  (# thrd: ^thread;                     (* Current thread of execution *)
     unwind: ##stackUnwinder;           (* Never NONE *)
     l2ndcl: ^l2NameDcl;                (* Never NONE *)
     l1ent: ^l1Entity;                  (* Never NONE nor 'freshAttribute' *)
     offset: @integer;                  (* Placement of 'l2ndcl' in 'attrs' *)
     attr: ^l1MapElement                (* private *)
  enter (thrd[],unwind##,l2ndcl[])
  <<SLOT CompositeObjectSliceAttrsLookup:dopart>>
  exit l1ent[]
  #);

attrsLookupAttr:
  (# thrd: ^thread;                     (* Current thread of execution *)
     unwind: ##stackUnwinder;           (* Never NONE *)
     l2ndcl: ^l2NameDcl;                (* Never NONE *)
     offset: @integer;                  (* Placement of 'l2ndcl' in 'attrs' *)
     oofo: ^stackableObject;            (* Used during lazy init *)
     attr: ^l1MapElement                (* Never NONE *)
  enter (thrd[],unwind##,l2ndcl[])
  <<SLOT CompositeObjectSliceAttrsLookupAttr:dopart>>
  exit attr[]
  #);

attrsCompiledFillInAttribute:
  (# thrd: ^thread;                     (* Current thread of execution *)
     unwind: ##stackUnwinder;           (* Never NONE *)
     l2ast: ^l2AstNode;                 (* Never NONE *)
     l2adcl: ^l2AttributeDecl;          (* Never NONE *)
     attr: ^l1MapElement;               (* Never NONE *)
     oofo: ^stackableObject;            (* Used during lazy init *)
     l1ent: ^l1Entity
  enter (thrd[],unwind##,attr[])
  <<SLOT CompositeObjectSliceAttrsCompiledFill:dopart>>
  exit l1ent[]
  #)

(*
 * local variables:
 * ee-beta-main-file: "/src/main/gbeta.bet"
 * end:
 *)
